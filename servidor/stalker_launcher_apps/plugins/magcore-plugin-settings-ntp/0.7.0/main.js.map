{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/js/main.js","webpack:///./node_modules/mag-gettext/index.js","webpack:///./node_modules/cjs-emitter/index.js","webpack:///./node_modules/cjs-gettext/index.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","restartTimer","gettext","gettextWrapper","onInit","config","callback","onAppInit","onSettingsInit","load","window","core","environment","language","path","result","content","id","parent","type","description","label","ntpurl","icon","render","api","renders","input","getters","prepareForRender","data","this","prepareForSave","clearTimeout","setTimeout","gSTB","ServiceControl","actions","setInfo","saver","savers","build","Emitter","Gettext","loader","prepare","_","pgettext","ngettext","defaultLanguage","xhr","ext","XMLHttpRequest","onload","jsonParseError","json","JSON","parse","responseText","error","onerror","events","emit","ontimeout","open","send","addListener","push","once","self","onceWrapper","removeListener","apply","arguments","addListeners","callbacks","filter","fn","length","undefined","index","event","Array","slice","constructor","meta","msgId","context","plural","evalResult","eval"],"mappings":"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","file":"main.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","/**\n * Created by bas.\n */\n\n'use strict';\n\nvar gettextWrapper = require('mag-gettext'),\n    restartTimer, gettext;\n\nfunction build ( config ) {\n    var result = {\n        content: [\n            {\n                id: 'ntp',\n                parent: 'system',\n                type: 'option',\n                name: gettext('NTP server'),\n                description: [\n                    {\n                        label: gettext('URL') + ':',\n                        value: window.core.environment.ntpurl\n                    }, {\n                        label: '',\n                        value: gettext('Setting up the NTP server as a time source to synchronize time on a set-top box via a local or Internet network.')  // eslint-disable-line\n                    }\n                ],\n                icon: 'theme-icon-ntp-server',\n                config: {type: 'qwerty'},\n                render: config.api.renders.input,\n                getter: config.api.getters.environment,\n                environment: {\n                    ntpurl: 'pool.ntp.org'\n                },\n                prepareForRender: function ( data, callback ) {\n                    this.config.value = data['ntpurl'];\n                    callback();\n                },\n                prepareForSave: function ( value, callback ) {\n                    this.environment['ntpurl'] = value;\n                    clearTimeout(restartTimer);\n                    restartTimer = setTimeout(function () {\n                        gSTB.ServiceControl('ntp', 'restart');\n                    }, 100);\n                    callback(null, function () {\n                        //console.log('call setInfo ' + typeof config.api.actions.setInfo);\n                        config.api.actions.setInfo({\n                            description: [\n                                {\n                                    label: gettext('URL') + ':',\n                                    value: value\n                                }, {\n                                    label: '',\n                                    value: gettext('Setting up the NTP server as a time source to synchronize time on a set-top box via a local or Internet network.')  // eslint-disable-line\n                                }\n                            ]\n                        });\n                        if ( result && result.content && result.content[0] && result.content[0].description ) {\n                            result.content[0].description[0].value = value;\n                        }\n                    });\n                },\n                saver: config.api.savers.environment\n            }\n        ]\n    };\n\n    return result;\n}\n\n\nmodule.exports = {\n    onInit: function ( config, callback ) {\n        callback();\n    },\n    onAppInit: function ( config, callback ) {\n        callback(null, {});\n    },\n    onSettingsInit: function ( config, callback ) {\n        gettextWrapper.load({\n            name: window.core.environment.language,\n            path: config.path + 'lang'\n        }, function () {\n            gettext = gettextWrapper.gettext;\n            callback(null, build(config));\n        });\n    }\n};\n","/**\n * @license The MIT License (MIT)\n * @copyright Stanislav Kalashnik <darkpark.main@gmail.com>\n */\n\n/* eslint no-path-concat: 0 */\n\n'use strict';\n\nvar Emitter = require('cjs-emitter'),\n    Gettext = require('cjs-gettext'),\n    loader  = new Emitter();\n\n\nif ( DEVELOP ) {\n    loader._ = loader.gettext = loader.pgettext = loader.ngettext = function () {\n        throw new Error(__filename + ': you cannot use this function before mag-gettext not yet loaded');\n    };\n}\n\n/**\n * Wrap the given data with gettext instance\n * and export methods to the global scope.\n *\n * @param {Object} [data] localization data\n */\nfunction prepare ( data ) {\n    var gettext = new Gettext(data);\n\n    loader._ = loader.gettext = gettext.gettext;\n    loader.pgettext = gettext.pgettext;\n    loader.ngettext = gettext.ngettext;\n}\n\n\n/**\n * Main application language\n */\nloader.defaultLanguage = 'en';\n\n\n/**\n * Simple gettext implementation.\n *\n * @param {Object} config options\n * @param {string} [config.path=lang] relative path to project root\n * @param {string} config.name language name\n * @param {string} [config.ext=json] language file extension\n * @param {function} callback hook on ready\n */\nloader.load = function ( config, callback ) {\n    var xhr;\n\n    if ( DEVELOP ) {\n        if ( !config.name || typeof config.name !== 'string' ) {\n            throw new Error(__filename + ': config.name must be a nonempty string');\n        }\n        if ( callback && typeof callback !== 'function' ) {\n            throw new Error(__filename + ': wrong callback type');\n        }\n    }\n\n    // defaults\n\n    callback = callback || null;\n    config.ext  = config.ext  || 'json';\n    config.path = config.path || 'lang';\n\n    // is it necessary to request a localization file?\n    if ( config.name === loader.defaultLanguage ) {\n        // no\n        prepare();\n        if ( callback !== null ) {\n            callback(null);\n        }\n    } else {\n        xhr = new XMLHttpRequest();\n\n        xhr.onload = function () {\n            var jsonParseError, json;\n\n            try {\n                json = JSON.parse(xhr.responseText);\n            } catch ( error ) {\n                jsonParseError = error;\n            }\n\n            if ( jsonParseError ) {\n                xhr.onerror(jsonParseError);\n            } else {\n                prepare(json);\n                if ( callback !== null ) {\n                    callback(null);\n                }\n\n                // there are some listeners\n                if ( loader.events['load'] ) {\n                    // notify listeners\n                    loader.emit('load');\n                }\n            }\n        };\n\n        xhr.ontimeout = xhr.onerror = function ( error ) {\n            prepare();\n\n            if ( callback !== null ) {\n                callback(null);\n            }\n\n            // there are some listeners\n            if ( loader.events['error'] ) {\n                // notify listeners\n                loader.emit('error', error);\n            }\n        };\n\n        xhr.open('GET', config.path + '/' + config.name + '.' + config.ext, true);\n        xhr.send(null);\n    }\n};\n\n\n// public\nmodule.exports = loader;\n","/**\n * @license The MIT License (MIT)\n * @author Stanislav Kalashnik <darkpark.main@gmail.com>\n */\n\n/* eslint no-path-concat: 0 */\n\n'use strict';\n\n\n/**\n * Base Events Emitter implementation.\n *\n * @see http://nodejs.org/api/events.html\n * @constructor\n *\n * @example\n * var emitter = new Emitter();\n */\nfunction Emitter () {\n    console.assert(typeof this === 'object', 'must be constructed via new');\n\n    // if ( DEVELOP ) {\n    //     if ( typeof this !== 'object' ) { throw new Error(__filename + ': must be constructed via new'); }\n    // }\n\n    /**\n     * Inner hash table for event names and linked callbacks.\n     * Manual editing should be avoided.\n     *\n     * @member {Object.<string, function[]>}\n     *\n     * @example\n     * {\n     *     click: [\n     *         function click1 () { ... },\n     *         function click2 () { ... }\n     *     ],\n     *     keydown: [\n     *         function () { ... }\n     *     ]\n     * }\n     **/\n    this.events = {};\n}\n\n\nEmitter.prototype = {\n    /**\n     * Bind an event to the given callback function.\n     * The same callback function can be added multiple times for the same event name.\n     *\n     * @param {string} name event identifier\n     * @param {function} callback function to call on this event\n     *\n     * @example\n     * emitter.addListener('click', function ( data ) { ... });\n     * // one more click handler\n     * emitter.addListener('click', function ( data ) { ... });\n     */\n    addListener: function ( name, callback ) {\n        console.assert(arguments.length === 2, 'wrong arguments number');\n        console.assert(typeof name === 'string', 'wrong name type');\n        console.assert(name.length > 0, 'empty name');\n        console.assert(typeof callback === 'function', 'callback should be a function');\n\n        // if ( DEVELOP ) {\n        //     if ( arguments.length !== 2 ) { throw new Error(__filename + ': wrong arguments number'); }\n        //     if ( typeof name !== 'string' || name.length === 0 ) { throw new Error(__filename + ': wrong or empty name'); }\n        //     if ( typeof callback !== 'function' ) { throw new Error(__filename + ': wrong callback type'); }\n        // }\n\n        // initialization may be required\n        this.events[name] = this.events[name] || [];\n        // append this new event to the list\n        this.events[name].push(callback);\n    },\n\n\n    /**\n     * Add a one time listener for the event.\n     * This listener is invoked only the next time the event is fired, after which it is removed.\n     *\n     * @param {string} name event identifier\n     * @param {function} callback function to call on this event\n     *\n     * @example\n     * emitter.once('click', function ( data ) { ... });\n     */\n    once: function ( name, callback ) {\n        // current execution context\n        var self = this;\n\n        if ( DEVELOP ) {\n            if ( arguments.length !== 2 ) {\n                throw new Error(__filename + ': wrong arguments number');\n            }\n            if ( typeof name !== 'string' || name.length === 0 ) {\n                throw new Error(__filename + ': wrong or empty name');\n            }\n            if ( typeof callback !== 'function' ) {\n                throw new Error(__filename + ': wrong callback type');\n            }\n        }\n\n        // initialization may be required\n        this.events[name] = this.events[name] || [];\n        // append this new event to the list\n        this.events[name].push(function onceWrapper () {\n            self.removeListener(name, onceWrapper);\n            callback.apply(self, arguments);\n        });\n    },\n\n\n    /**\n     * Apply multiple listeners at once.\n     *\n     * @param {Object} callbacks event names with callbacks\n     *\n     * @example\n     * emitter.addListeners({\n     *     click: function ( data ) {},\n     *     close: function ( data ) {}\n     * });\n     */\n    addListeners: function ( callbacks ) {\n        var name;\n\n        if ( DEVELOP ) {\n            if ( arguments.length !== 1 ) {\n                throw new Error(__filename + ': wrong arguments number');\n            }\n            if ( typeof callbacks !== 'object' ) {\n                throw new Error(__filename + ': wrong callbacks type');\n            }\n            if ( Object.keys(callbacks).length === 0 ) {\n                throw new Error(__filename + ': no callbacks given');\n            }\n        }\n\n        for ( name in callbacks ) {\n            if ( callbacks.hasOwnProperty(name) ) {\n                this.addListener(name, callbacks[name]);\n            }\n        }\n    },\n\n\n    /**\n     * Remove all instances of the given callback.\n     *\n     * @param {string} name event identifier\n     * @param {function} callback function to remove\n     *\n     * @example\n     * emitter.removeListener('click', func1);\n     */\n    removeListener: function ( name, callback ) {\n        if ( DEVELOP ) {\n            if ( arguments.length !== 2 ) {\n                throw new Error(__filename + ': wrong arguments number');\n            }\n            if ( typeof name !== 'string' || name.length === 0 ) {\n                throw new Error(__filename + ': wrong or empty name');\n            }\n            if ( typeof callback !== 'function' ) {\n                throw new Error(__filename + ': wrong callback type');\n            }\n            if ( this.events[name] && !Array.isArray(this.events[name]) ) {\n                throw new Error(__filename + ': corrupted inner data');\n            }\n        }\n\n        // the event exists and should have some callbacks\n        if ( this.events[name] ) {\n            // rework the callback list to exclude the given one\n            this.events[name] = this.events[name].filter(function callbacksFilter ( fn ) { return fn !== callback; });\n            // event has no more callbacks so clean it\n            if ( this.events[name].length === 0 ) {\n                // as if there were no listeners at all\n                this.events[name] = undefined;\n            }\n        }\n    },\n\n\n    /**\n     * Remove all callbacks for the given event name.\n     * Without event name clears all events.\n     *\n     * @param {string} [name] event identifier\n     *\n     * @example\n     * emitter.removeAllListeners('click');\n     * emitter.removeAllListeners();\n     *\n     * @deprecated\n     */\n    /*removeAllListeners: function ( name ) {\n        if ( DEVELOP ) {\n            if ( arguments.length !== 0 && (typeof name !== 'string' || name.length === 0) ) {\n                throw new Error(__filename + ': wrong or empty name');\n            }\n        }\n\n        // check input\n        if ( arguments.length === 0 ) {\n            // no arguments so remove everything\n            this.events = {};\n        } else if ( name ) {\n            if ( DEVELOP ) {\n                if ( this.events[name] ) { throw new Error(__filename + ': event is not removed'); }\n            }\n\n            // only name is given so remove all callbacks for the given event\n            // but object structure modification should be avoided\n            this.events[name] = undefined;\n        }\n    },*/\n\n\n    /**\n     * Execute each of the listeners in the given order with the supplied arguments.\n     *\n     * @param {string} name event identifier\n     *\n     * @example\n     * emitter.emit('init');\n     * emitter.emit('click', {src: panel1, dst: panel2});\n     * emitter.emit('load', error, data);\n     *\n     * // it's a good idea to emit event only when there are some listeners\n     * if ( this.events['click'] ) {\n     *     this.emit('click', {event: event});\n     * }\n     */\n    emit: function ( name ) {\n        var event = this.events[name],\n            index;\n\n        if ( DEVELOP ) {\n            if ( arguments.length < 1 ) {\n                throw new Error(__filename + ': wrong arguments number');\n            }\n            if ( typeof name !== 'string' || name.length === 0 ) {\n                throw new Error(__filename + ': wrong or empty name');\n            }\n        }\n\n        // the event exists and should have some callbacks\n        if ( event ) {\n            if ( DEVELOP ) {\n                if ( !Array.isArray(event) ) {\n                    throw new Error(__filename + ': wrong event type');\n                }\n            }\n\n            for ( index = 0; index < event.length; index++ ) {\n                if ( DEVELOP ) {\n                    if ( typeof event[index] !== 'function' ) {\n                        throw new Error(__filename + ': wrong event callback type');\n                    }\n                }\n\n                // invoke the callback with parameters\n                event[index].apply(this, Array.prototype.slice.call(arguments, 1));\n            }\n        }\n    }\n};\n\n\n// correct constructor name\nEmitter.prototype.constructor = Emitter;\n\n\n// public\nmodule.exports = Emitter;\n","/**\n * @license The MIT License (MIT)\n * @author Stanislav Kalashnik <darkpark.main@gmail.com>\n */\n\n/* eslint no-path-concat: 0 */\n\n'use strict';\n\n\n/**\n * Translations handler.\n *\n * @constructor\n *\n * @param {Object} config init parameters\n */\nfunction Gettext ( config ) {\n    var data, meta;\n\n    // sanitize\n    config   = config || {};\n    data     = config.data || {};\n    data[''] = data[''] || {};\n\n    // shortcut\n    meta = config.meta;\n\n    /**\n     * Display the native language translation of a textual message.\n     *\n     * @param {string} msgId textual message\n     *\n     * @return {string} translated text\n     */\n    this.gettext = function ( msgId ) {\n        return data[''][msgId] || msgId;\n    };\n\n\n    /**\n     * The \"p\" in \"pgettext\" stands for \"particular\": fetches a particular translation of the textual message.\n     *\n     * @param {string} context message context\n     * @param {string} msgId textual message\n     *\n     * @return {string} translated text\n     */\n    this.pgettext = function ( context, msgId ) {\n        return data[context] && data[context][msgId] || msgId;\n    };\n\n\n    /**\n     * Display the native language translation of a textual message whose grammatical form depends on a number.\n     *\n     * @param {string} msgId textual message in a singular form\n     * @param {string} plural textual message in a plural form\n     * @param {number} value message number\n     *\n     * @return {string} translated text\n     */\n    this.ngettext = function ( msgId, plural, value ) {\n        /* eslint no-unused-vars: 0 */\n        /* eslint no-eval: 0 */\n        /* eslint id-length: 0 */\n        var n, evalResult;\n\n        if ( DEVELOP ) {\n            if ( Number(value) !== value ) {\n                throw new Error(__filename + ': value must be a number');\n            }\n        }\n\n        if ( data && meta && data[''][msgId] ) {\n            evalResult = eval('n = ' + value + '; ' + meta.plural);\n\n            if ( typeof evalResult === 'boolean' ) {\n                evalResult = +evalResult;\n            }\n\n            // translation\n            return data[''][msgId][evalResult];\n        }\n\n        // english\n        return value === 1 ? msgId : plural;\n    };\n}\n\n\n// correct constructor name\nGettext.prototype.constructor = Gettext;\n\n\n// public\nmodule.exports = Gettext;\n"],"sourceRoot":""}
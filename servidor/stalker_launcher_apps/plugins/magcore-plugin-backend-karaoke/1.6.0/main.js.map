{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/js/modules/data.provider.js","webpack:///./node_modules/cjs-emitter/index.js","webpack:///./src/js/main.js","webpack:///./src/js/modules/app.api.provider.js","webpack:///./src/js/config.js","webpack:///./src/js/modules/launcher.api.provider.js","webpack:///./node_modules/mag-gettext/index.js","webpack:///./node_modules/cjs-gettext/index.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","config","badRequestError","message","getTracks","queryStringSet","callback","queryString","keys","forEach","index","array","length","core","backend","request","resource","onload","error","response","onerror","getPlaybackLink","trackID","karaokeLink","join","setFavoriteState","favoriteState","method","body","Emitter","this","events","addListener","push","once","self","onceWrapper","removeListener","apply","arguments","addListeners","callbacks","filter","fn","undefined","emit","event","Array","slice","constructor","onAppInit","onContentBoardInit","dataProvider","getTracksCallback","result","tracks","isArray","data","map","item","performer","url","solution","id","favorite","getPlaybackLinkCallback","setFavoriteStateCallback","JSON","stringify","intentContext","RESOLUTION","screen","height","uniqueItemID","gettextWrapper","load","environment","language","path","_","gettext","contentProvider","launcherAPI","api","layout","layouts","static","geometry","square","setup","tracksAmount","moreButton","icon","normal","active","runApp","search","onClick","playKaraokeTrack","allTracksQueue","intentData","action","mime","uri","title","mediaId","context","hide","close","prev","indexOf","next","intent","sort","track1","track2","provider","concat","Gettext","loader","prepare","pgettext","ngettext","defaultLanguage","xhr","ext","XMLHttpRequest","jsonParseError","json","parse","responseText","ontimeout","open","send","meta","msgId","plural","evalResult","eval"],"mappings":"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","file":"main.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n","/**\n * Implement accessing to a karaoke songs list, favorites list.\n * Inner API realization as an abstract level for specific providers.\n *\n * @module data.provider\n */\n\n'use strict';\n\nvar config          = require('../config'),\n    badRequestError = {message: 'Bad request error!'};\n\n\nmodule.exports = {\n    /**\n     * Get all karaoke tracks from server or search by given request string (as a part of query string).\n     *\n     * @param {Object} queryStringSet - set of name-value GET parameters\n     * @param {Function} callback - callback function\n     */\n    getTracks: function ( queryStringSet, callback ) {\n        var queryString = '?';\n\n        Object.keys(queryStringSet).forEach(function ( name, index, array ) {\n            queryString += name + '=' + queryStringSet[name] + ['&', ''][+(index === array.length - 1)];\n        });\n\n        core.backend.request(config.resource + queryString, {\n            onload: function ( error, response ) {\n                if ( error ) {\n                    callback(badRequestError);\n                } else {\n                    callback(null, response);\n                }\n            },\n            onerror: function () {\n                callback(badRequestError);\n            }\n        });\n    },\n\n    /**\n     * Return URL for playback.\n     *\n     * @param {number} trackID - ID of karaoke track\n     * @param {Function} callback - callback function\n     */\n    getPlaybackLink: function ( trackID, callback ) {\n        core.backend.request(config.resource + [trackID, config.karaokeLink].join('/'), {\n            onload: function ( error, response ) {\n                if ( error ) {\n                    callback(badRequestError);\n                } else {\n                    callback(null, response);\n                }\n            },\n            onerror: function () {\n                callback(badRequestError);\n            }\n        });\n    },\n\n    /**\n     * Add or delete karaoke track from favorites list.\n     *\n     * @param {number} trackID - ID of karaoke track\n     * @param {string|boolean} favoriteState - favorites flag in some form\n     * @param {Function} callback - callback function\n     */\n    setFavoriteState: function ( trackID, favoriteState, callback ) {\n        core.backend.request(config.resource + trackID, {\n            method: 'PUT',\n            body: favoriteState,\n            onload: function ( error, response ) {\n                if ( error ) {\n                    callback(badRequestError);\n                } else {\n                    callback(null, response);\n                }\n            },\n            onerror: function () {\n                callback(badRequestError);\n            }\n        });\n    }\n};\n","/**\n * @license The MIT License (MIT)\n * @author Stanislav Kalashnik <darkpark.main@gmail.com>\n */\n\n/* eslint no-path-concat: 0 */\n\n'use strict';\n\n\n/**\n * Base Events Emitter implementation.\n *\n * @see http://nodejs.org/api/events.html\n * @constructor\n *\n * @example\n * var emitter = new Emitter();\n */\nfunction Emitter () {\n    console.assert(typeof this === 'object', 'must be constructed via new');\n\n    // if ( DEVELOP ) {\n    //     if ( typeof this !== 'object' ) { throw new Error(__filename + ': must be constructed via new'); }\n    // }\n\n    /**\n     * Inner hash table for event names and linked callbacks.\n     * Manual editing should be avoided.\n     *\n     * @member {Object.<string, function[]>}\n     *\n     * @example\n     * {\n     *     click: [\n     *         function click1 () { ... },\n     *         function click2 () { ... }\n     *     ],\n     *     keydown: [\n     *         function () { ... }\n     *     ]\n     * }\n     **/\n    this.events = {};\n}\n\n\nEmitter.prototype = {\n    /**\n     * Bind an event to the given callback function.\n     * The same callback function can be added multiple times for the same event name.\n     *\n     * @param {string} name event identifier\n     * @param {function} callback function to call on this event\n     *\n     * @example\n     * emitter.addListener('click', function ( data ) { ... });\n     * // one more click handler\n     * emitter.addListener('click', function ( data ) { ... });\n     */\n    addListener: function ( name, callback ) {\n        console.assert(arguments.length === 2, 'wrong arguments number');\n        console.assert(typeof name === 'string', 'wrong name type');\n        console.assert(name.length > 0, 'empty name');\n        console.assert(typeof callback === 'function', 'callback should be a function');\n\n        // if ( DEVELOP ) {\n        //     if ( arguments.length !== 2 ) { throw new Error(__filename + ': wrong arguments number'); }\n        //     if ( typeof name !== 'string' || name.length === 0 ) { throw new Error(__filename + ': wrong or empty name'); }\n        //     if ( typeof callback !== 'function' ) { throw new Error(__filename + ': wrong callback type'); }\n        // }\n\n        // initialization may be required\n        this.events[name] = this.events[name] || [];\n        // append this new event to the list\n        this.events[name].push(callback);\n    },\n\n\n    /**\n     * Add a one time listener for the event.\n     * This listener is invoked only the next time the event is fired, after which it is removed.\n     *\n     * @param {string} name event identifier\n     * @param {function} callback function to call on this event\n     *\n     * @example\n     * emitter.once('click', function ( data ) { ... });\n     */\n    once: function ( name, callback ) {\n        // current execution context\n        var self = this;\n\n        if ( DEVELOP ) {\n            if ( arguments.length !== 2 ) {\n                throw new Error(__filename + ': wrong arguments number');\n            }\n            if ( typeof name !== 'string' || name.length === 0 ) {\n                throw new Error(__filename + ': wrong or empty name');\n            }\n            if ( typeof callback !== 'function' ) {\n                throw new Error(__filename + ': wrong callback type');\n            }\n        }\n\n        // initialization may be required\n        this.events[name] = this.events[name] || [];\n        // append this new event to the list\n        this.events[name].push(function onceWrapper () {\n            self.removeListener(name, onceWrapper);\n            callback.apply(self, arguments);\n        });\n    },\n\n\n    /**\n     * Apply multiple listeners at once.\n     *\n     * @param {Object} callbacks event names with callbacks\n     *\n     * @example\n     * emitter.addListeners({\n     *     click: function ( data ) {},\n     *     close: function ( data ) {}\n     * });\n     */\n    addListeners: function ( callbacks ) {\n        var name;\n\n        if ( DEVELOP ) {\n            if ( arguments.length !== 1 ) {\n                throw new Error(__filename + ': wrong arguments number');\n            }\n            if ( typeof callbacks !== 'object' ) {\n                throw new Error(__filename + ': wrong callbacks type');\n            }\n            if ( Object.keys(callbacks).length === 0 ) {\n                throw new Error(__filename + ': no callbacks given');\n            }\n        }\n\n        for ( name in callbacks ) {\n            if ( callbacks.hasOwnProperty(name) ) {\n                this.addListener(name, callbacks[name]);\n            }\n        }\n    },\n\n\n    /**\n     * Remove all instances of the given callback.\n     *\n     * @param {string} name event identifier\n     * @param {function} callback function to remove\n     *\n     * @example\n     * emitter.removeListener('click', func1);\n     */\n    removeListener: function ( name, callback ) {\n        if ( DEVELOP ) {\n            if ( arguments.length !== 2 ) {\n                throw new Error(__filename + ': wrong arguments number');\n            }\n            if ( typeof name !== 'string' || name.length === 0 ) {\n                throw new Error(__filename + ': wrong or empty name');\n            }\n            if ( typeof callback !== 'function' ) {\n                throw new Error(__filename + ': wrong callback type');\n            }\n            if ( this.events[name] && !Array.isArray(this.events[name]) ) {\n                throw new Error(__filename + ': corrupted inner data');\n            }\n        }\n\n        // the event exists and should have some callbacks\n        if ( this.events[name] ) {\n            // rework the callback list to exclude the given one\n            this.events[name] = this.events[name].filter(function callbacksFilter ( fn ) { return fn !== callback; });\n            // event has no more callbacks so clean it\n            if ( this.events[name].length === 0 ) {\n                // as if there were no listeners at all\n                this.events[name] = undefined;\n            }\n        }\n    },\n\n\n    /**\n     * Remove all callbacks for the given event name.\n     * Without event name clears all events.\n     *\n     * @param {string} [name] event identifier\n     *\n     * @example\n     * emitter.removeAllListeners('click');\n     * emitter.removeAllListeners();\n     *\n     * @deprecated\n     */\n    /*removeAllListeners: function ( name ) {\n        if ( DEVELOP ) {\n            if ( arguments.length !== 0 && (typeof name !== 'string' || name.length === 0) ) {\n                throw new Error(__filename + ': wrong or empty name');\n            }\n        }\n\n        // check input\n        if ( arguments.length === 0 ) {\n            // no arguments so remove everything\n            this.events = {};\n        } else if ( name ) {\n            if ( DEVELOP ) {\n                if ( this.events[name] ) { throw new Error(__filename + ': event is not removed'); }\n            }\n\n            // only name is given so remove all callbacks for the given event\n            // but object structure modification should be avoided\n            this.events[name] = undefined;\n        }\n    },*/\n\n\n    /**\n     * Execute each of the listeners in the given order with the supplied arguments.\n     *\n     * @param {string} name event identifier\n     *\n     * @example\n     * emitter.emit('init');\n     * emitter.emit('click', {src: panel1, dst: panel2});\n     * emitter.emit('load', error, data);\n     *\n     * // it's a good idea to emit event only when there are some listeners\n     * if ( this.events['click'] ) {\n     *     this.emit('click', {event: event});\n     * }\n     */\n    emit: function ( name ) {\n        var event = this.events[name],\n            index;\n\n        if ( DEVELOP ) {\n            if ( arguments.length < 1 ) {\n                throw new Error(__filename + ': wrong arguments number');\n            }\n            if ( typeof name !== 'string' || name.length === 0 ) {\n                throw new Error(__filename + ': wrong or empty name');\n            }\n        }\n\n        // the event exists and should have some callbacks\n        if ( event ) {\n            if ( DEVELOP ) {\n                if ( !Array.isArray(event) ) {\n                    throw new Error(__filename + ': wrong event type');\n                }\n            }\n\n            for ( index = 0; index < event.length; index++ ) {\n                if ( DEVELOP ) {\n                    if ( typeof event[index] !== 'function' ) {\n                        throw new Error(__filename + ': wrong event callback type');\n                    }\n                }\n\n                // invoke the callback with parameters\n                event[index].apply(this, Array.prototype.slice.call(arguments, 1));\n            }\n        }\n    }\n};\n\n\n// correct constructor name\nEmitter.prototype.constructor = Emitter;\n\n\n// public\nmodule.exports = Emitter;\n","/**\n * Entry point for backend plugin.\n * Consists of various types of API initializers.\n */\n\n'use strict';\n\nmodule.exports = {\n    /** Initialization of API provider for application. */\n    onAppInit: require('./modules/app.api.provider'),\n    /** Initialization of API provider for external (Prime Launcher for now) subscriber. */\n    onContentBoardInit: require('./modules/launcher.api.provider')\n};\n","/**\n * Provide convenient API for application.\n * Use abstract data provider for data retrieving and handle it for application purposes.\n *\n * @module app.api.provider\n */\n\n'use strict';\n\n\nmodule.exports = function ( config, callback ) {\n    var dataProvider = require('./data.provider'),\n        api = {\n            /**\n             * Return a handled list of karaoke tracks for app.\n             *\n             * @param {Object} queryStringSet - set of name-value GET parameters\n             * @param {Function} getTracksCallback - callback function\n             */\n            getTracks: function ( queryStringSet, getTracksCallback ) {\n                dataProvider.getTracks(queryStringSet, function ( error, result ) {\n                    var tracks;\n\n                    if ( error ) {\n                        getTracksCallback({message: 'Bad request error!'});\n                    } else {\n                        try {\n                            if ( Array.isArray(result.data) ) {\n                                tracks = result.data.map(function ( item ) {\n                                    return {\n                                        performer: item.performer,\n                                        name:      item.name,\n                                        url:       item.url,\n                                        solution:  item.solution,\n                                        id:        item.id,\n                                        favorite:  item.favorite\n                                    };\n                                });\n\n                                getTracksCallback(null, tracks);\n                            } else {\n                                getTracksCallback({message: 'Parse result error!'});\n                            }\n                        } catch ( error ) {\n                            getTracksCallback({message: 'Parse result error!'});\n                        }\n                    }\n                });\n            },\n\n            /**\n             * Return URL for playback.\n             *\n             * @param {number} trackID - ID of karaoke track\n             * @param {Function} getPlaybackLinkCallback - callback function\n             */\n            getPlaybackLink: function ( trackID, getPlaybackLinkCallback ) {\n                dataProvider.getPlaybackLink(trackID, getPlaybackLinkCallback);\n            },\n\n            /**\n             * Add or delete track from favorites list.\n             *\n             * @param {number} trackID - ID of the karaoke track\n             * @param {boolean} favoriteState - favorites flag\n             * @param {Function} setFavoriteStateCallback - callback function\n             */\n            setFavoriteState: function ( trackID, favoriteState, setFavoriteStateCallback ) {\n                dataProvider.setFavoriteState(trackID, JSON.stringify({favorite: favoriteState}), setFavoriteStateCallback);\n            }\n        };\n\n    callback(null, api);\n};\n","/**\n * Global application configuration.\n * Can store run-time options, API urls, paths, execution flags and so on.\n * Automatically loaded on application initialization and available as app.config.\n */\n\n'use strict';\n\nmodule.exports = {\n    resource: 'karaokes/',\n    karaokeLink: 'link'\n};\n","/**\n * Provide convenient API for Prime Launcher.\n * Use abstract data provider for data retrieving and handle it for Prime Launcher purposes.\n *\n * @module launcher.api.provider\n */\n\n'use strict';\n\nvar RESOLUTION   = screen.height,\n    uniqueItemID = 1,\n    intentContext,\n    index;\n\n\n/**\n * Play karaoke track via sending intent.\n *\n * @param {Object[]} allTracksQueue - all retrieved karaoke tracks to play\n * @param {Object} item - resource to open\n */\nfunction playKaraokeTrack ( allTracksQueue, item ) {\n    var intentData = {\n        action: 'play',\n        mime: 'content/video',\n        data: {\n            uri:      item.url,\n            title:    item.name,\n            solution: item.solution || 'auto',\n            mediaId:  item.id\n        },\n        context: intentContext,\n        events: {\n            error: function () {\n                intentContext = null;\n            },\n            hide: function () {\n                intentContext = null;\n            },\n            close: function () {\n                intentContext = null;\n            },\n            prev: function () {\n                index = allTracksQueue.indexOf(item);\n\n                playKaraokeTrack(allTracksQueue, allTracksQueue[--index % allTracksQueue.length]);\n            },\n            next: function () {\n                index = allTracksQueue.indexOf(item);\n\n                playKaraokeTrack(allTracksQueue, allTracksQueue[++index % allTracksQueue.length]);\n            }\n        }\n    };\n\n    // delete intent events depending on file position in queue, disable \"prev\" on the first one and \"next\" on the last\n    if ( !index ) {\n        delete intentData.events.prev;\n    }\n\n    if ( index === allTracksQueue.length - 1 ) {\n        delete intentData.events.next;\n    }\n\n    core.intent(intentData, function ( error, context ) {\n        if ( !error ) {\n            intentContext = context;\n        }\n    });\n}\n\n\nmodule.exports = function ( config, callback ) {\n    var gettextWrapper = require('mag-gettext');\n\n    gettextWrapper.load({\n        name: core.environment.language,\n        path: config.path + 'lang'\n    }, function () {\n        var dataProvider    = require('./data.provider'),\n            Emitter         = require('cjs-emitter'),\n            _               = gettextWrapper.gettext,\n            contentProvider = new Emitter(),\n            launcherAPI     = config.api,\n            layout          = launcherAPI.layouts.static,\n            geometry        = launcherAPI.geometry.square,\n            setup           = {\n                // how many tracks send to Prime Launcher (max)\n                tracksAmount: 10,\n                moreButton: {\n                    id:       ++uniqueItemID,\n                    layout:   layout,\n                    geometry: geometry,\n                    data: {\n                        name: _('See more'),\n                        icon: {\n                            normal: config.path + 'img/' + RESOLUTION + '/see.more.normal.png',\n                            active: config.path + 'img/' + RESOLUTION + '/see.more.active.png'\n                        }\n                    },\n                    runApp: true\n                    /*onClick: function () {\n                        core.intent({\n                            action: 'karaoke:open',\n                            events: {}\n                        }, function ( error ) {\n                            if ( error ) {\n                                console.log(error);\n                            }\n                        });\n                    }*/\n                }\n            };\n\n\n        /**\n         * Content search.\n         *\n         * @param {Object} config - configuration for search\n         * @param {string} config.query - query search request\n         * @param {Function} callback - which called when content is ready\n         */\n        contentProvider.search = function ( config, callback ) { // eslint-disable-line\n            // @TODO: query data and invoke `callback(error, ContentItem[]);`\n        };\n\n\n        // collect data for Leanback Launcher on start\n        dataProvider.getTracks({favorite: false}, function ( error, result ) {\n            var tracks;\n\n            if ( error ) {\n                /*--------------------------\n                 Here and in all such cases... if first argument (error) is object (or something truthy) it's the signal\n                 to Leanback Launcher to supress plugin output, even content string doesn't show\n                --------------------------*/\n\n                callback(error);\n            } else {\n                try {\n                    if ( Array.isArray(result.data) ) {\n                        tracks = result.data\n                            .map(function ( item ) {\n                                return {\n                                    id:       ++uniqueItemID,\n                                    layout:   layout,\n                                    geometry: geometry,\n                                    data: {\n                                        name:      item.name,\n                                        /*performer: item.performer,\n                                        url:       item.url,\n                                        solution:  item.solution,\n                                        id:        item.id,\n                                        favorite:  item.favorite,*/\n                                        icon: {\n                                            normal: config.path + 'img/' + RESOLUTION + '/content.item.normal.png',\n                                            active: config.path + 'img/' + RESOLUTION + '/content.item.active.png'\n                                        }\n                                    },\n                                    onClick: function () {\n                                        playKaraokeTrack(result.data, item);\n                                    }\n                                };\n                            })\n                            .sort(function ( track1, track2 ) {\n                                if ( !track1.data.favorite && track2.data.favorite ) {\n                                    return 1;\n                                }\n\n                                return -1;\n                            })\n                            .slice(0, setup.tracksAmount);\n\n                        callback(null, {\n                            provider: contentProvider,\n                            data: tracks.length ? tracks.concat(setup.moreButton) : []\n                        });\n                    } else {\n                        callback(true);\n                    }\n                } catch ( error ) {\n                    callback(error);\n                }\n            }\n        });\n    });\n};\n","/**\n * @license The MIT License (MIT)\n * @copyright Stanislav Kalashnik <darkpark.main@gmail.com>\n */\n\n/* eslint no-path-concat: 0 */\n\n'use strict';\n\nvar Emitter = require('cjs-emitter'),\n    Gettext = require('cjs-gettext'),\n    loader  = new Emitter();\n\n\nif ( DEVELOP ) {\n    loader._ = loader.gettext = loader.pgettext = loader.ngettext = function () {\n        throw new Error(__filename + ': you cannot use this function before mag-gettext not yet loaded');\n    };\n}\n\n/**\n * Wrap the given data with gettext instance\n * and export methods to the global scope.\n *\n * @param {Object} [data] localization data\n */\nfunction prepare ( data ) {\n    var gettext = new Gettext(data);\n\n    loader._ = loader.gettext = gettext.gettext;\n    loader.pgettext = gettext.pgettext;\n    loader.ngettext = gettext.ngettext;\n}\n\n\n/**\n * Main application language\n */\nloader.defaultLanguage = 'en';\n\n\n/**\n * Simple gettext implementation.\n *\n * @param {Object} config options\n * @param {string} [config.path=lang] relative path to project root\n * @param {string} config.name language name\n * @param {string} [config.ext=json] language file extension\n * @param {function} callback hook on ready\n */\nloader.load = function ( config, callback ) {\n    var xhr;\n\n    if ( DEVELOP ) {\n        if ( !config.name || typeof config.name !== 'string' ) {\n            throw new Error(__filename + ': config.name must be a nonempty string');\n        }\n        if ( callback && typeof callback !== 'function' ) {\n            throw new Error(__filename + ': wrong callback type');\n        }\n    }\n\n    // defaults\n\n    callback = callback || null;\n    config.ext  = config.ext  || 'json';\n    config.path = config.path || 'lang';\n\n    // is it necessary to request a localization file?\n    if ( config.name === loader.defaultLanguage ) {\n        // no\n        prepare();\n        if ( callback !== null ) {\n            callback(null);\n        }\n    } else {\n        xhr = new XMLHttpRequest();\n\n        xhr.onload = function () {\n            var jsonParseError, json;\n\n            try {\n                json = JSON.parse(xhr.responseText);\n            } catch ( error ) {\n                jsonParseError = error;\n            }\n\n            if ( jsonParseError ) {\n                xhr.onerror(jsonParseError);\n            } else {\n                prepare(json);\n                if ( callback !== null ) {\n                    callback(null);\n                }\n\n                // there are some listeners\n                if ( loader.events['load'] ) {\n                    // notify listeners\n                    loader.emit('load');\n                }\n            }\n        };\n\n        xhr.ontimeout = xhr.onerror = function ( error ) {\n            prepare();\n\n            if ( callback !== null ) {\n                callback(null);\n            }\n\n            // there are some listeners\n            if ( loader.events['error'] ) {\n                // notify listeners\n                loader.emit('error', error);\n            }\n        };\n\n        xhr.open('GET', config.path + '/' + config.name + '.' + config.ext, true);\n        xhr.send(null);\n    }\n};\n\n\n// public\nmodule.exports = loader;\n","/**\n * @license The MIT License (MIT)\n * @author Stanislav Kalashnik <darkpark.main@gmail.com>\n */\n\n/* eslint no-path-concat: 0 */\n\n'use strict';\n\n\n/**\n * Translations handler.\n *\n * @constructor\n *\n * @param {Object} config init parameters\n */\nfunction Gettext ( config ) {\n    var data, meta;\n\n    // sanitize\n    config   = config || {};\n    data     = config.data || {};\n    data[''] = data[''] || {};\n\n    // shortcut\n    meta = config.meta;\n\n    /**\n     * Display the native language translation of a textual message.\n     *\n     * @param {string} msgId textual message\n     *\n     * @return {string} translated text\n     */\n    this.gettext = function ( msgId ) {\n        return data[''][msgId] || msgId;\n    };\n\n\n    /**\n     * The \"p\" in \"pgettext\" stands for \"particular\": fetches a particular translation of the textual message.\n     *\n     * @param {string} context message context\n     * @param {string} msgId textual message\n     *\n     * @return {string} translated text\n     */\n    this.pgettext = function ( context, msgId ) {\n        return data[context] && data[context][msgId] || msgId;\n    };\n\n\n    /**\n     * Display the native language translation of a textual message whose grammatical form depends on a number.\n     *\n     * @param {string} msgId textual message in a singular form\n     * @param {string} plural textual message in a plural form\n     * @param {number} value message number\n     *\n     * @return {string} translated text\n     */\n    this.ngettext = function ( msgId, plural, value ) {\n        /* eslint no-unused-vars: 0 */\n        /* eslint no-eval: 0 */\n        /* eslint id-length: 0 */\n        var n, evalResult;\n\n        if ( DEVELOP ) {\n            if ( Number(value) !== value ) {\n                throw new Error(__filename + ': value must be a number');\n            }\n        }\n\n        if ( data && meta && data[''][msgId] ) {\n            evalResult = eval('n = ' + value + '; ' + meta.plural);\n\n            if ( typeof evalResult === 'boolean' ) {\n                evalResult = +evalResult;\n            }\n\n            // translation\n            return data[''][msgId][evalResult];\n        }\n\n        // english\n        return value === 1 ? msgId : plural;\n    };\n}\n\n\n// correct constructor name\nGettext.prototype.constructor = Gettext;\n\n\n// public\nmodule.exports = Gettext;\n"],"sourceRoot":""}
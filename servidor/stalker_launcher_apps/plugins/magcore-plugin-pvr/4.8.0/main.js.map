{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/cjs-emitter/index.js","webpack:///./src/js/main.js","webpack:///./node_modules/mag-gettext/index.js","webpack:///./node_modules/cjs-gettext/index.js","webpack:///./node_modules/magcore-plugin-content-board/index.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","Emitter","this","events","addListener","callback","push","once","self","onceWrapper","removeListener","apply","arguments","addListeners","callbacks","filter","fn","length","undefined","emit","index","event","Array","slice","constructor","daemon","gettext","gettextWrapper","apiConst","provider","providerDaemon","stateToText","recordStates","WAITING","RECORDING","ERROR","FINISHED","errors","badArgument","code","message","notEnoughMemory","wrongRange","taskWasNotFound","wrongFileName","duplicateTasks","badStream","errorOpeningFile","tasksLimit","gotEndOfStream","errorWritingFile","wrongUrl","wrongFilename","wrongStartTime","wrongEndtime","wrongObject","idToError","-1","-2","-3","-4","-5","-6","-7","-8","-9","-10","-11","-12","-13","-14","-15","-16","Record","data","id","state","url","path","channel","startTime","endTime","progress","server","errorCode","Client","trigger","list","rawDataList","forEach","item","onChange","record","idToIndexHash","oldValue","curr","old","time","Date","now","onAdd","onRemove","splice","onProgress","triggers","destroy","indexOf","checkTimerId","checkTime","lostEvents","remove","add","sync","rawData","ind","isActive","JSON","parse","pvrManager","GetAllTasks","error","fileName","split","pop","callOnAdd","addItem","Math","ceil","callOnProgress","emitProgress","callOnChange","emitChange","array1","array2","array2index","array1index","current","array1length","array2length","difference","arraysDifference","removed","recordIndex","listener","removeItem","window","setInterval","stop","ChangeEndTime","states","stateCode","names","map","array","extension","trim","substring","join","CreateTask","options","RemoveTask","deleteFile","wrapped","layout","layouts","geometry","horizontal","mime","deleted","init","api","search","text","onInit","config","load","core","environment","language","onAppInit","onContentBoardInit","Gettext","loader","prepare","_","pgettext","ngettext","defaultLanguage","xhr","ext","XMLHttpRequest","onload","jsonParseError","json","responseText","onerror","ontimeout","open","send","meta","msgId","context","plural","evalResult","eval","tvChannel","video","static","application","square","vertical","round","actions","favorite","accessControl","expandItemContent"],"mappings":"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","file":"main.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","/**\n * @license The MIT License (MIT)\n * @author Stanislav Kalashnik <darkpark.main@gmail.com>\n */\n\n/* eslint no-path-concat: 0 */\n\n'use strict';\n\n\n/**\n * Base Events Emitter implementation.\n *\n * @see http://nodejs.org/api/events.html\n * @constructor\n *\n * @example\n * var emitter = new Emitter();\n */\nfunction Emitter () {\n    console.assert(typeof this === 'object', 'must be constructed via new');\n\n    // if ( DEVELOP ) {\n    //     if ( typeof this !== 'object' ) { throw new Error(__filename + ': must be constructed via new'); }\n    // }\n\n    /**\n     * Inner hash table for event names and linked callbacks.\n     * Manual editing should be avoided.\n     *\n     * @member {Object.<string, function[]>}\n     *\n     * @example\n     * {\n     *     click: [\n     *         function click1 () { ... },\n     *         function click2 () { ... }\n     *     ],\n     *     keydown: [\n     *         function () { ... }\n     *     ]\n     * }\n     **/\n    this.events = {};\n}\n\n\nEmitter.prototype = {\n    /**\n     * Bind an event to the given callback function.\n     * The same callback function can be added multiple times for the same event name.\n     *\n     * @param {string} name event identifier\n     * @param {function} callback function to call on this event\n     *\n     * @example\n     * emitter.addListener('click', function ( data ) { ... });\n     * // one more click handler\n     * emitter.addListener('click', function ( data ) { ... });\n     */\n    addListener: function ( name, callback ) {\n        console.assert(arguments.length === 2, 'wrong arguments number');\n        console.assert(typeof name === 'string', 'wrong name type');\n        console.assert(name.length > 0, 'empty name');\n        console.assert(typeof callback === 'function', 'callback should be a function');\n\n        // if ( DEVELOP ) {\n        //     if ( arguments.length !== 2 ) { throw new Error(__filename + ': wrong arguments number'); }\n        //     if ( typeof name !== 'string' || name.length === 0 ) { throw new Error(__filename + ': wrong or empty name'); }\n        //     if ( typeof callback !== 'function' ) { throw new Error(__filename + ': wrong callback type'); }\n        // }\n\n        // initialization may be required\n        this.events[name] = this.events[name] || [];\n        // append this new event to the list\n        this.events[name].push(callback);\n    },\n\n\n    /**\n     * Add a one time listener for the event.\n     * This listener is invoked only the next time the event is fired, after which it is removed.\n     *\n     * @param {string} name event identifier\n     * @param {function} callback function to call on this event\n     *\n     * @example\n     * emitter.once('click', function ( data ) { ... });\n     */\n    once: function ( name, callback ) {\n        // current execution context\n        var self = this;\n\n        if ( DEVELOP ) {\n            if ( arguments.length !== 2 ) {\n                throw new Error(__filename + ': wrong arguments number');\n            }\n            if ( typeof name !== 'string' || name.length === 0 ) {\n                throw new Error(__filename + ': wrong or empty name');\n            }\n            if ( typeof callback !== 'function' ) {\n                throw new Error(__filename + ': wrong callback type');\n            }\n        }\n\n        // initialization may be required\n        this.events[name] = this.events[name] || [];\n        // append this new event to the list\n        this.events[name].push(function onceWrapper () {\n            self.removeListener(name, onceWrapper);\n            callback.apply(self, arguments);\n        });\n    },\n\n\n    /**\n     * Apply multiple listeners at once.\n     *\n     * @param {Object} callbacks event names with callbacks\n     *\n     * @example\n     * emitter.addListeners({\n     *     click: function ( data ) {},\n     *     close: function ( data ) {}\n     * });\n     */\n    addListeners: function ( callbacks ) {\n        var name;\n\n        if ( DEVELOP ) {\n            if ( arguments.length !== 1 ) {\n                throw new Error(__filename + ': wrong arguments number');\n            }\n            if ( typeof callbacks !== 'object' ) {\n                throw new Error(__filename + ': wrong callbacks type');\n            }\n            if ( Object.keys(callbacks).length === 0 ) {\n                throw new Error(__filename + ': no callbacks given');\n            }\n        }\n\n        for ( name in callbacks ) {\n            if ( callbacks.hasOwnProperty(name) ) {\n                this.addListener(name, callbacks[name]);\n            }\n        }\n    },\n\n\n    /**\n     * Remove all instances of the given callback.\n     *\n     * @param {string} name event identifier\n     * @param {function} callback function to remove\n     *\n     * @example\n     * emitter.removeListener('click', func1);\n     */\n    removeListener: function ( name, callback ) {\n        if ( DEVELOP ) {\n            if ( arguments.length !== 2 ) {\n                throw new Error(__filename + ': wrong arguments number');\n            }\n            if ( typeof name !== 'string' || name.length === 0 ) {\n                throw new Error(__filename + ': wrong or empty name');\n            }\n            if ( typeof callback !== 'function' ) {\n                throw new Error(__filename + ': wrong callback type');\n            }\n            if ( this.events[name] && !Array.isArray(this.events[name]) ) {\n                throw new Error(__filename + ': corrupted inner data');\n            }\n        }\n\n        // the event exists and should have some callbacks\n        if ( this.events[name] ) {\n            // rework the callback list to exclude the given one\n            this.events[name] = this.events[name].filter(function callbacksFilter ( fn ) { return fn !== callback; });\n            // event has no more callbacks so clean it\n            if ( this.events[name].length === 0 ) {\n                // as if there were no listeners at all\n                this.events[name] = undefined;\n            }\n        }\n    },\n\n\n    /**\n     * Remove all callbacks for the given event name.\n     * Without event name clears all events.\n     *\n     * @param {string} [name] event identifier\n     *\n     * @example\n     * emitter.removeAllListeners('click');\n     * emitter.removeAllListeners();\n     *\n     * @deprecated\n     */\n    /*removeAllListeners: function ( name ) {\n        if ( DEVELOP ) {\n            if ( arguments.length !== 0 && (typeof name !== 'string' || name.length === 0) ) {\n                throw new Error(__filename + ': wrong or empty name');\n            }\n        }\n\n        // check input\n        if ( arguments.length === 0 ) {\n            // no arguments so remove everything\n            this.events = {};\n        } else if ( name ) {\n            if ( DEVELOP ) {\n                if ( this.events[name] ) { throw new Error(__filename + ': event is not removed'); }\n            }\n\n            // only name is given so remove all callbacks for the given event\n            // but object structure modification should be avoided\n            this.events[name] = undefined;\n        }\n    },*/\n\n\n    /**\n     * Execute each of the listeners in the given order with the supplied arguments.\n     *\n     * @param {string} name event identifier\n     *\n     * @example\n     * emitter.emit('init');\n     * emitter.emit('click', {src: panel1, dst: panel2});\n     * emitter.emit('load', error, data);\n     *\n     * // it's a good idea to emit event only when there are some listeners\n     * if ( this.events['click'] ) {\n     *     this.emit('click', {event: event});\n     * }\n     */\n    emit: function ( name ) {\n        var event = this.events[name],\n            index;\n\n        if ( DEVELOP ) {\n            if ( arguments.length < 1 ) {\n                throw new Error(__filename + ': wrong arguments number');\n            }\n            if ( typeof name !== 'string' || name.length === 0 ) {\n                throw new Error(__filename + ': wrong or empty name');\n            }\n        }\n\n        // the event exists and should have some callbacks\n        if ( event ) {\n            if ( DEVELOP ) {\n                if ( !Array.isArray(event) ) {\n                    throw new Error(__filename + ': wrong event type');\n                }\n            }\n\n            for ( index = 0; index < event.length; index++ ) {\n                if ( DEVELOP ) {\n                    if ( typeof event[index] !== 'function' ) {\n                        throw new Error(__filename + ': wrong event callback type');\n                    }\n                }\n\n                // invoke the callback with parameters\n                event[index].apply(this, Array.prototype.slice.call(arguments, 1));\n            }\n        }\n    }\n};\n\n\n// correct constructor name\nEmitter.prototype.constructor = Emitter;\n\n\n// public\nmodule.exports = Emitter;\n","/**\n * MAGSDK basic implementation of pvr plugin.\n * Before use stb player should be initialised by calling gSTB.InitPlayer().\n *\n * @author Fedotov Dmitry <bas.jsdev@gmail.com>\n */\n\n'use strict';\n\nvar Emitter        = require('cjs-emitter'),\n    gettextWrapper = require('mag-gettext'),\n    apiConst       = require('magcore-plugin-content-board'),\n    // data provider for Leanback Launcher\n    provider       = new Emitter(),\n    providerDaemon = {},\n    stateToText    = ['', 'Scheduled recording', 'Recording', 'Recording error!', 'Recorded'],\n    recordStates   = {\n        /** @const {number} */\n        WAITING:   1,\n        /** @const {number} */\n        RECORDING: 2,\n        /** @const {number} */\n        ERROR:     3,\n        /** @const {number} */\n        FINISHED:  4\n    },\n    errors         = {\n        badArgument:      {code: '-1', message: 'Wrong record parameters.'},\n        notEnoughMemory:  {code: '-2', message: 'Not enough memory.'},\n        wrongRange:       {code: '-3', message: 'Wrong record range. Record length must be less than 24 hours.'},\n        taskWasNotFound:  {code: '-4', message: 'Task with specified ID was not found.'},\n        wrongFileName:    {code: '-5', message: 'Wrong file name. Folder where you want to save recording must exist.'},\n        duplicateTasks:   {code: '-6', message: 'Record with that name already exists.'},\n        badStream:        {code: '-7', message: 'Error opening stream URL.'},\n        errorOpeningFile: {code: '-8', message: 'Error opening output file.'},\n        tasksLimit:       {code: '-9', message: 'Maximum number of simultaneous recording is exceeded.'},\n        gotEndOfStream:   {code: '-10', message: 'Records app got a thread exit notification. File record is over.'},\n        errorWritingFile: {\n            code:    '-11',\n            message: 'Error writing file. Probably the disk is full or has been disconnected during recording.'\n        },\n        wrongUrl:         {code: '-12', message: 'Wrong record url.'},\n        wrongFilename:    {code: '-13', message: 'Wrong file name.'},\n        wrongStartTime:   {code: '-14', message: 'Wrong record start time.'},\n        wrongEndtime:     {code: '-15', message: 'Wrong record end time.'},\n        wrongObject:      {code: '-16', message: 'Bad record.'}\n    },\n    idToError      = {\n        '-1':  'badArgument',\n        '-2':  'notEnoughMemory',\n        '-3':  'wrongRange',\n        '-4':  'taskWasNotFound',\n        '-5':  'wrongFileName',\n        '-6':  'duplicateTasks',\n        '-7':  'badStream',\n        '-8':  'errorOpeningFile',\n        '-9':  'tasksLimit',\n        '-10': 'gotEndOfStream',\n        '-11': 'errorWritingFile',\n        '-12': 'wrongUrl',\n        '-13': 'wrongFilename',\n        '-14': 'wrongStartTime',\n        '-15': 'wrongEndtime',\n        '-16': 'wrongObject'\n    },\n    daemon, gettext;\n\n\n// Get difference between two arrays\nfunction arraysDifference ( array1, array2 ) {\n    var array1length = array1.length,\n        array2length = array2.length,\n        difference   = [],\n        array2index, array1index, current;\n\n    for ( current = 0; current < array1length; current++ ) {\n        array2index = array1index = 0;\n\n        while ( array2index < array2length && array2[array2index].id !== array1[current].id ) {\n            array2index++;\n        }\n\n        while ( array1index < difference.length && difference[array1index].id !== array1[current].id ) {\n            array1index++;\n        }\n\n        if ( array2index === array2length && array1index === difference.length ) {\n            difference[difference.length] = array1[current];\n        }\n    }\n\n    return difference;\n}\n\n\n/**\n * Callback for called method.\n *\n * @callback callback\n *\n * @param {Object} [config] result data\n * @param {Object} [config.curr] new property value (for example if event 'state' was emitted here will be new state value)\n * @param {Object} [config.old] old property value\n * @param {Object} [config.time] for cache reset\n * @param {Record} config.item record object (with applied changes)\n * @param {Object} [error] error data\n * @param {Object} error.code error code\n * @param {Object} error.message error text message\n */\n\n\n/**\n * Watching for any changes in records on gSTB level and if there are some - triggering corresponding callbacks in clients.\n * Can't be reached from application scope.\n *\n * @namespace\n */\ndaemon = {\n    /**\n     * Id from update setInterval function\n     *\n     * @type {number}\n     */\n    checkTimerId: 0,\n    /**\n     * Interval between updates (between pvrManager.GetAllTasks() function calls)\n     *\n     * @type {number}\n     */\n    checkTime: 2000,\n    /**\n     * List of clients listeners. For example to make first client update progress for recordItem and emit event\n     * 'progress' for his app, you should call daemon.triggers[0].onProgress(recordItem).\n     *\n     * @type {Array}\n     */\n    triggers: [],\n    /**\n     * Stack for asynchronous callbacks. For example delay between STB record creation call and record appearance in\n     * STB records list can be more than few seconds. So callback will wait in stack till corresponding new record\n     * would be fond by sync operation.\n     *\n     * @type {Object}\n     */\n    lostEvents: {\n        remove: {},\n        add:    {}\n    },\n    /**\n     * Raw records data from pvrManager.GetAllTasks() call\n     *\n     * @type {Array}\n     */\n    rawDataList: [],\n    /**\n     * Hash to connect raw records data and records objects in clients. Otherwise on each update operation we should\n     * use multiple cycles to build connections between raw data and record objects and only then apply changes.\n     *\n     * @type {Object}\n     */\n    idToIndexHash: {},\n    /**\n     * Synchronise changes in records on gSTB level and if there are some - trigger corresponding callbacks in clients.\n     *\n     * @type {Function}\n     */\n    sync: function () {\n        var rawData, index, ind, progress, difference;\n\n        if ( !daemon.triggers.length && !providerDaemon.isActive ) {\n            // nobody listen so no need for data update\n            return;\n        }\n\n        try {\n            rawData = JSON.parse(pvrManager.GetAllTasks());\n            //console.log('pvrManager.GetAllTasks(): ' + pvrManager.GetAllTasks());\n        } catch ( error ) {\n            rawData = [];\n        }\n\n        // Optimise use of 'forEach' inside 'for' cycle\n        function callOnAdd ( item ) {\n            if ( typeof item.onAdd === 'function' ) {\n                item.onAdd(daemon.rawDataList[daemon.rawDataList.length - 1]);\n            }\n        }\n\n        // Optimise use of 'forEach' inside 'for' cycle\n        function callOnProgress ( item ) {\n            if ( typeof item.onProgress === 'function' ) {\n                item.onProgress(daemon.rawDataList[index]);\n            }\n        }\n\n        // Optimise use of 'forEach' inside 'for' cycle\n        function callOnChange ( item ) {\n            if ( typeof item.onChange === 'function' ) {\n                item.onChange(daemon.rawDataList[index]);\n            }\n        }\n\n        for ( ind = 0; ind < rawData.length; ind++ ) {\n            index = daemon.idToIndexHash[rawData[ind].id];\n            if ( index === undefined ) {\n                // add new record data\n                daemon.rawDataList.push({\n                    id:        rawData[ind].id,\n                    state:     rawData[ind].state,\n                    url:       rawData[ind].url,\n                    path:      rawData[ind].fileName,\n                    channel:   rawData[ind].fileName.split('records/')[1].split('/')[0],\n                    name:      rawData[ind].fileName.split('/').pop(),\n                    startTime: rawData[ind].startTime,\n                    endTime:   rawData[ind].endTime,\n                    // all completed should have 100% progress\n                    progress:  rawData[ind].state === recordStates.FINISHED ? 100 : 0,\n                    server:    false,\n                    errorCode: rawData[ind].errorCode\n                });\n                daemon.idToIndexHash[rawData[ind].id] = daemon.rawDataList.length - 1;\n                // trigger callback from client.add(data, callback); call\n                if ( daemon.lostEvents.add[rawData[ind].fileName] ) {\n                    if ( typeof daemon.lostEvents.add[rawData[ind].fileName] === 'function' ) {\n                        daemon.lostEvents.add[rawData[ind].fileName](daemon.rawDataList[daemon.rawDataList.length - 1]);\n                    }\n                    delete daemon.lostEvents.add[rawData[ind].fileName];\n                }\n                // trigger onAdd function in clients\n                daemon.triggers.forEach(callOnAdd);\n                // add new item in provider list\n                providerDaemon.addItem(daemon.rawDataList[daemon.rawDataList.length - 1]);\n            } else {\n                // check if progress changed (every running and finished task -\n                // because of async API, we need to sync progress and state separately)\n                if ( rawData[ind].state === recordStates.RECORDING || rawData[ind].state === recordStates.FINISHED ) {\n                    progress = Math.ceil((((Date.now() / 1000) - rawData[ind].startTime) /\n                        (rawData[ind].endTime - rawData[ind].startTime)) * 100);\n                    progress = progress < 0 ? 0 : progress;\n                    progress = progress > 100 ? 100 : progress;\n                    if ( progress !== daemon.rawDataList[index].progress ) {\n                        daemon.rawDataList[index].progress = progress;\n                        daemon.triggers.forEach(callOnProgress);\n                        // tell provider to update item progress\n                        providerDaemon.emitProgress(daemon.rawDataList[index]);\n                    }\n                }\n                // check if state changed\n                if ( rawData[ind].state !== daemon.rawDataList[index].state ) {\n                    daemon.rawDataList[index].state = rawData[ind].state;\n                    daemon.rawDataList[index].errorCode = rawData[ind].errorCode;\n                    // trigger onChange function in clients\n                    daemon.triggers.forEach(callOnChange);\n                    // tell provider to update item status\n                    providerDaemon.emitChange(daemon.rawDataList[index]);\n                }\n            }\n        }\n\n        // find deleted records\n        if ( rawData.length !== daemon.rawDataList.length ) {\n            difference = arraysDifference(daemon.rawDataList, rawData);\n\n            difference.forEach(function ( record ) {\n                var recordIndex = daemon.rawDataList.indexOf(record),\n                    removed;\n\n                // trigger callback from client.remove(record, callback) call\n                if ( daemon.lostEvents.remove[record.path] ) {\n                    if ( typeof daemon.lostEvents.remove[record.path] === 'function' ) {\n                        daemon.lostEvents.remove[record.path](record);\n                    }\n                    delete daemon.lostEvents.remove[record.path];\n                }\n\n                removed = daemon.rawDataList.splice(recordIndex, 1);\n                // tell clients about deleted record and give it index for fast search and deletion\n                daemon.triggers.forEach(function ( listener ) {\n                    if ( typeof listener.onRemove === 'function' ) {\n                        listener.onRemove(record, recordIndex);\n                    }\n                });\n                // tell provider to remove item\n                providerDaemon.removeItem(removed[0]);\n            });\n        }\n    }\n};\n\n// start listening to STB right now\ndaemon.sync();\ndaemon.checkTimerId = window.setInterval(daemon.sync, daemon.checkTime);\n\n\n/**\n * Wrapper with stop method for record data obtained by calling pvrManager.GetAllTasks().\n * If record information would be changed it will emit corresponding event.\n *\n * @constructor\n * @extends Emitter\n *\n * @param {Object} data - result of pvrManager.GetAllTasks() call\n *\n * @example\n * var record = new Record(JSON.parse(pvrManager.GetAllTasks())[0]);\n */\nfunction Record ( data ) {\n    Emitter.call(this);\n    this.data = {\n        id:        data.id,\n        state:     data.state,\n        url:       data.url,\n        path:      data.path,\n        channel:   data.channel,\n        name:      data.name,\n        startTime: data.startTime,\n        endTime:   data.endTime,\n        progress:  data.progress,\n        server:    data.server,\n        errorCode: data.errorCode\n    };\n}\n\nRecord.prototype = Object.create(Emitter.prototype);\nRecord.prototype.constructor = Record;\n\n\n/**\n * Stop recording. Record end time will be set to current and as result it will change state to finished.\n *\n * @param {callback} callback - callback function\n */\nRecord.prototype.stop = function ( callback ) {\n    pvrManager.ChangeEndTime(this.data.id, Math.ceil(Date.now() / 1000));\n    if ( typeof callback === 'function' ) {\n        callback({item: this}, null);\n    }\n};\n\n\n/**\n * Record states dictionary (this constants should be used instead of numbers for state comparison).\n *\n * @namespace\n */\nRecord.prototype.states = recordStates;\n\n\n/**\n * Record manager. Listening daemon for records changes and emitting corresponding events to application.\n * Can emit events: progress, state, add, remove.\n *\n * @constructor\n * @extends Emitter\n */\nfunction Client () {\n    var self    = this,\n        trigger = {};\n\n    Emitter.call(this);\n\n    this.list = [];\n\n    daemon.rawDataList.forEach(function ( item ) {\n        self.list.push(new Record(item));\n    });\n\n    trigger.onChange = function ( item ) {\n        var record   = self.list[daemon.idToIndexHash[item.id]],\n            oldValue = record.data.state;\n\n        record.data.state = item.state;\n        if ( record.events['state'] ) {\n            record.emit('state', {\n                item: record,\n                curr: record.data.state,\n                old:  oldValue,\n                time: Date.now()\n            });\n        }\n    };\n    trigger.onAdd = function ( item ) {\n        self.list.push(new Record(item));\n        if ( self.events['add'] ) {\n            self.emit('add', {item: self.list[self.list.length - 1], time: Date.now()});\n        }\n    };\n    trigger.onRemove = function ( item, index ) {\n        if ( self.events['remove'] ) {\n            self.emit('remove', {item: (self.list.splice(index, 1))[0], time: Date.now()});\n        }\n    };\n    trigger.onProgress = function ( item ) {\n        var record   = self.list[daemon.idToIndexHash[item.id]],\n            oldValue = record.data.progress;\n\n        record.data.progress = item.progress;\n        if ( record.events['progress'] ) {\n            record.emit('progress', {\n                item: record,\n                curr: record.data.progress,\n                old:  oldValue,\n                time: Date.now()\n            });\n        }\n    };\n\n    daemon.triggers.push(trigger);\n\n    /**\n     * Stop this client and remove all it listeners. Use it for cleanup before application exit.\n     */\n    this.destroy = function () {\n        daemon.triggers.splice(daemon.triggers.indexOf(trigger), 1);\n        this.events = {};\n        this.list = [];\n    };\n}\n\n\nClient.prototype = Object.create(Emitter.prototype);\nClient.prototype.constructor = Client;\n\n\n/**\n * Record states dictionary (this constants should be used instead of numbers for state comparison).\n *\n */\nClient.prototype.recordStates = recordStates;\n\n\n/**\n * Create new record.\n *\n * @param {Object} data - record info\n * @param {string} data.name - path to file\n * @param {string} data.channel - channel url\n * @param {number} data.startTime - start time\n * @param {number} data.endTime - end time\n * @param {callback} callback - callback function\n *\n * @example\n * pvr.add({\n *     name: '/media/USB-94F9AM9X43RO31TW-1/records/EurosportLive/2016-03-16/00-00-01.ts',\n *     channel: 'rtp://239.1.1.1:1234',\n *     startTime: Math.ceil(Date.now() / 1000 + 10),\n *     endTime: Math.ceil(Date.now() / 1000 + 500)\n * }, function ( error, data ) {\n *     console.log(error);\n *     console.log(data);\n * });\n */\nClient.prototype.add = function ( data, callback ) {\n    var stateCode, names;\n\n    if ( typeof callback !== 'function' ) {\n        console.log('Wrong callback function.');\n\n        return;\n    }\n    if ( !data.channel ) {\n        callback(null, errors.wrongUrl);\n\n        return;\n    }\n    if ( !data.name || typeof data.name !== 'string' ) {\n        callback(null, errors.wrongFileName);\n\n        return;\n    }\n    if ( !data.startTime ) {\n        callback(null, errors.wrongStartTime);\n\n        return;\n    }\n    if ( !data.endTime ) {\n        callback(null, errors.wrongObject);\n\n        return;\n    }\n\n    // check folders/file name\n    names = data.name.split('/').map(function ( name, index, array ) {\n        var extension;\n\n        // name length should be less than 248 symbols and they should not start/end with space symbol (API limitation)\n        name = (name || '').trim();\n        if ( name.length >= 247 ) {\n            if ( index === array.length - 1 ) {\n                // file\n                extension = '.' + name.split('.').pop();\n                name = name.substring(0, 247 - extension.length);\n                name += extension;\n            } else {\n                // folder\n                name = name.substring(0, 247);\n            }\n        }\n\n        return name;\n    });\n    data.name = names.join('/');\n\n    daemon.lostEvents.add[data.name] = callback;\n\n    stateCode = pvrManager.CreateTask(data.channel, data.name, data.startTime, data.endTime);\n\n    if ( idToError[stateCode] ) {\n        callback(null, errors[idToError[stateCode]]);\n        // Error happened so record will not be created. Clear unreachable onAdd callback.\n        delete daemon.lostEvents.add[data.name];\n    }\n};\n\n\n/**\n * Remove record.\n *\n * @param {Record} item - record instance\n * @param {Object} options - delete options\n * @param {boolean} options.deleteFile - if true then both file and task will be deleted, if false - only task\n * @param {callback} callback - callback function\n */\nClient.prototype.remove = function ( item, options, callback ) {\n    options = options || {};\n\n    if ( typeof callback !== 'function' ) {\n        console.log('Wrong callback function.');\n\n        return;\n    }\n    if ( !item || !(item instanceof Record) ) {\n        callback(null, errors.wrongObject);\n\n        return;\n    }\n\n    daemon.lostEvents.remove[item.data.path] = callback;\n\n    // 0     | do not remove any files\n    // 1     | if temporary file exists, rename it into resulting file\n    // 2     | remove only temporary file, if it exists\n    // 3     | remove both temporary and resulting files\n    pvrManager.RemoveTask(item.data.id, options.deleteFile ? 3 : 1);\n};\n\nproviderDaemon = {\n    /**\n     * No need for this daemon so turn it off\n     */\n    isActive: false,\n    /**\n     * Hash to connect raw records data and records objects. Otherwise on each update operation we should\n     * use multiple cycles to build connections between raw data and record objects and only then apply changes.\n     *\n     * @type {Object}\n     */\n    idToIndexHash: {},\n    list: [],\n    /**\n     * Synchronise changes in records on gSTB level and if there are some - trigger corresponding callbacks in clients.\n     *\n     * @param {Object} item - wrapped record\n     */\n    emitChange: function ( item ) {\n        try {\n            providerDaemon.idToIndexHash[item.id].state = stateToText[item.state];\n            providerDaemon.idToIndexHash[item.id].emit('change');\n        } catch ( error ) {\n            console.log('pvr provider: error in one of \"add\" listeners. ' + error);\n        }\n    },\n    emitProgress: function ( item ) {\n        try {\n            providerDaemon.idToIndexHash[item.id].progress = item.progress;\n            providerDaemon.idToIndexHash[item.id].emit('change');\n        } catch ( error ) {\n            console.log('pvr provider: error in one of \"add\" listeners. ' + error);\n        }\n    },\n    addItem: function ( item ) {\n        var wrapped = new Emitter();\n\n        wrapped.id = item.id;\n        wrapped.layout = apiConst.layouts.record;\n        wrapped.geometry = apiConst.geometry.horizontal;\n        wrapped.state = stateToText[item.state];\n        wrapped.progress = item.progress;\n        wrapped.data = {\n            name: item.name,\n            url:  item.path,\n            mime: 'content/video'\n        };\n\n        providerDaemon.idToIndexHash[item.id] = wrapped;\n        providerDaemon.list.push(wrapped);\n\n        try {\n            provider.emit('add', [wrapped]);\n        } catch ( error ) {\n            console.log('pvr provider: error in one of \"add\" listeners. ' + error);\n        }\n    },\n    removeItem: function ( item ) {\n        var deleted = providerDaemon.list.splice(providerDaemon.list.indexOf(providerDaemon.idToIndexHash[item.id]), 1);\n\n        delete providerDaemon.idToIndexHash[item.id];\n\n        try {\n            provider.emit('remove', deleted);\n        } catch ( error ) {\n            console.log('pvr provider: error in one of \"remove\" listeners. ' + error);\n        }\n    }\n};\n\n\nprovider.init = function ( api, callback ) {\n    this.api = api;\n\n    providerDaemon.isActive = true;\n\n    callback({\n        provider: provider,\n        data:     daemon.rawDataList.map(function ( item ) {\n            var wrapped = new Emitter();\n\n            wrapped.id = item.id;\n            wrapped.layout = apiConst.layouts.record;\n            wrapped.geometry = apiConst.geometry.horizontal;\n            wrapped.state = stateToText[item.state];\n            wrapped.progress = item.progress;\n            wrapped.data = {\n                name: item.name,\n                url:  item.path,\n                mime: 'content/video'\n            };\n\n            providerDaemon.idToIndexHash[item.id] = wrapped;\n            providerDaemon.list.push(wrapped);\n\n            return wrapped;\n        })\n    });\n};\n\nprovider.search = function ( text, callback ) {\n    callback(false, providerDaemon.list.map(function ( item ) {  // eslint-disable-line\n        if ( item.data.name.indexOf(text) !== -1 ) {\n            return item;\n        }\n    }));\n};\n\n\nmodule.exports = {\n    onInit: function ( config, callback ) {\n        gettextWrapper.load({\n            name: window.core.environment.language,\n            path: config.path + 'lang'\n        }, function () {\n            gettext = gettextWrapper.gettext;\n            stateToText = ['', gettext('Scheduled recording'), gettext('Recording'), gettext('Recording error!'), gettext('Recorded')];\n            callback();\n        });\n    },\n    onAppInit: function ( config, callback ) {\n        callback(null, new Client());\n    },\n    onContentBoardInit: function ( config, callback ) {\n        provider.init(config.api, function ( data ) {\n            callback(null, data);\n        });\n    }\n};\n","/**\n * @license The MIT License (MIT)\n * @copyright Stanislav Kalashnik <darkpark.main@gmail.com>\n */\n\n/* eslint no-path-concat: 0 */\n\n'use strict';\n\nvar Emitter = require('cjs-emitter'),\n    Gettext = require('cjs-gettext'),\n    loader  = new Emitter();\n\n\nif ( DEVELOP ) {\n    loader._ = loader.gettext = loader.pgettext = loader.ngettext = function () {\n        throw new Error(__filename + ': you cannot use this function before mag-gettext not yet loaded');\n    };\n}\n\n/**\n * Wrap the given data with gettext instance\n * and export methods to the global scope.\n *\n * @param {Object} [data] localization data\n */\nfunction prepare ( data ) {\n    var gettext = new Gettext(data);\n\n    loader._ = loader.gettext = gettext.gettext;\n    loader.pgettext = gettext.pgettext;\n    loader.ngettext = gettext.ngettext;\n}\n\n\n/**\n * Main application language\n */\nloader.defaultLanguage = 'en';\n\n\n/**\n * Simple gettext implementation.\n *\n * @param {Object} config options\n * @param {string} [config.path=lang] relative path to project root\n * @param {string} config.name language name\n * @param {string} [config.ext=json] language file extension\n * @param {function} callback hook on ready\n */\nloader.load = function ( config, callback ) {\n    var xhr;\n\n    if ( DEVELOP ) {\n        if ( !config.name || typeof config.name !== 'string' ) {\n            throw new Error(__filename + ': config.name must be a nonempty string');\n        }\n        if ( callback && typeof callback !== 'function' ) {\n            throw new Error(__filename + ': wrong callback type');\n        }\n    }\n\n    // defaults\n\n    callback = callback || null;\n    config.ext  = config.ext  || 'json';\n    config.path = config.path || 'lang';\n\n    // is it necessary to request a localization file?\n    if ( config.name === loader.defaultLanguage ) {\n        // no\n        prepare();\n        if ( callback !== null ) {\n            callback(null);\n        }\n    } else {\n        xhr = new XMLHttpRequest();\n\n        xhr.onload = function () {\n            var jsonParseError, json;\n\n            try {\n                json = JSON.parse(xhr.responseText);\n            } catch ( error ) {\n                jsonParseError = error;\n            }\n\n            if ( jsonParseError ) {\n                xhr.onerror(jsonParseError);\n            } else {\n                prepare(json);\n                if ( callback !== null ) {\n                    callback(null);\n                }\n\n                // there are some listeners\n                if ( loader.events['load'] ) {\n                    // notify listeners\n                    loader.emit('load');\n                }\n            }\n        };\n\n        xhr.ontimeout = xhr.onerror = function ( error ) {\n            prepare();\n\n            if ( callback !== null ) {\n                callback(null);\n            }\n\n            // there are some listeners\n            if ( loader.events['error'] ) {\n                // notify listeners\n                loader.emit('error', error);\n            }\n        };\n\n        xhr.open('GET', config.path + '/' + config.name + '.' + config.ext, true);\n        xhr.send(null);\n    }\n};\n\n\n// public\nmodule.exports = loader;\n","/**\n * @license The MIT License (MIT)\n * @author Stanislav Kalashnik <darkpark.main@gmail.com>\n */\n\n/* eslint no-path-concat: 0 */\n\n'use strict';\n\n\n/**\n * Translations handler.\n *\n * @constructor\n *\n * @param {Object} config init parameters\n */\nfunction Gettext ( config ) {\n    var data, meta;\n\n    // sanitize\n    config   = config || {};\n    data     = config.data || {};\n    data[''] = data[''] || {};\n\n    // shortcut\n    meta = config.meta;\n\n    /**\n     * Display the native language translation of a textual message.\n     *\n     * @param {string} msgId textual message\n     *\n     * @return {string} translated text\n     */\n    this.gettext = function ( msgId ) {\n        return data[''][msgId] || msgId;\n    };\n\n\n    /**\n     * The \"p\" in \"pgettext\" stands for \"particular\": fetches a particular translation of the textual message.\n     *\n     * @param {string} context message context\n     * @param {string} msgId textual message\n     *\n     * @return {string} translated text\n     */\n    this.pgettext = function ( context, msgId ) {\n        return data[context] && data[context][msgId] || msgId;\n    };\n\n\n    /**\n     * Display the native language translation of a textual message whose grammatical form depends on a number.\n     *\n     * @param {string} msgId textual message in a singular form\n     * @param {string} plural textual message in a plural form\n     * @param {number} value message number\n     *\n     * @return {string} translated text\n     */\n    this.ngettext = function ( msgId, plural, value ) {\n        /* eslint no-unused-vars: 0 */\n        /* eslint no-eval: 0 */\n        /* eslint id-length: 0 */\n        var n, evalResult;\n\n        if ( DEVELOP ) {\n            if ( Number(value) !== value ) {\n                throw new Error(__filename + ': value must be a number');\n            }\n        }\n\n        if ( data && meta && data[''][msgId] ) {\n            evalResult = eval('n = ' + value + '; ' + meta.plural);\n\n            if ( typeof evalResult === 'boolean' ) {\n                evalResult = +evalResult;\n            }\n\n            // translation\n            return data[''][msgId][evalResult];\n        }\n\n        // english\n        return value === 1 ? msgId : plural;\n    };\n}\n\n\n// correct constructor name\nGettext.prototype.constructor = Gettext;\n\n\n// public\nmodule.exports = Gettext;\n","'use strict';\n\n\n/** @namespace */\nmodule.exports = {\n    layouts: {\n        tvChannel: 1, // tv channel item with playback and epg now\n        video: 2,  // moview preview with play now item\n        record: 3, // audio preview with play now item\n        static: 4, // static item by default\n        application: 5\n    },\n    geometry: {\n        square: 1,\n        horizontal: 2,\n        vertical: 3,\n        round: 4\n    },\n    actions: { // actions which can be applied to item\n        favorite: 1,\n        accessControl: 2,\n        expandItemContent: 3\n    }\n};\n"],"sourceRoot":""}
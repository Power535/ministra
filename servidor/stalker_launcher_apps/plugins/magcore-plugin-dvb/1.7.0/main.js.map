{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/cjs-emitter/index.js","webpack:///./src/js/storage.js","webpack:///./src/js/main.js","webpack:///./node_modules/mag-gettext/index.js","webpack:///./node_modules/cjs-gettext/index.js","webpack:///./src/js/channel.class.js","webpack:///./src/js/epg.class.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","Emitter","this","events","addListener","callback","push","once","self","onceWrapper","removeListener","apply","arguments","addListeners","callbacks","filter","fn","length","undefined","emit","index","event","Array","slice","constructor","data","favoriteList","api","eventFunction","dataMap","globalEvent","gettext","gettextWrapper","Channel","storage","instanceList","channelList","types","supportedTypes","antennaStart","firstLoad","loadChannels","dvbManager","GetChannelList","channels","number","JSON","parse","error","parseInt","channel_number","id","url","solution","scrambled","genre","monitoring_status","build","check","description","icon","sections","parent","options","content","antenna","render","renders","toggle","saveImmediate","environment","prepareForRender","GetAntennaPower","prepareForSave","state","indexOf","SetAntennaPower","forEach","item","getters","saver","savers","type","popupSelect","requireDeviceReboot","dvb_type","opt","selected","Provider","supported","current","GetCurrentScanTypes","scanOptions","more","set","enable","getChannels","config","regExp","result","favorite","channel","byName","sort","ai","bi","search","RegExp","match","updateChannelsList","getLastChannelId","getItem","getCurrentChannelsEpg","map","getEPGBrief","getChannelsEpg","from","to","Math","round","getEpg","startAutoScan","ClearChannelList","input","SetScanParams","stringify","symRate","modulation","scanMode","networkId","StopChannelScan","code","info","stbEvent","onEnd","onProgress","onFound","StartChannelScan","autoScan","startManualScan","netId","frequency","StartChannelScanManual","frequencyEnd","band","manualScan","clearList","stopScan","destroy","splice","onAppInit","provider","init","onInit","GetSupportedScanTypes","core","notify","title","setTimeout","initData","onSettingsInit","load","language","path","Gettext","loader","prepare","_","pgettext","ngettext","defaultLanguage","xhr","ext","XMLHttpRequest","onload","jsonParseError","json","responseText","onerror","ontimeout","open","send","meta","msgId","context","plural","evalResult","eval","Epg","toggleFavorite","setItem","getUrl","now","Date","getFullYear","getMonth","getDate","GetEPGScheduleByRange","GetEPGBrief","setLast","remove","RemoveChannel","downloadable","start","end","duration","archive","details"],"mappings":"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","file":"main.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n","/**\n * @license The MIT License (MIT)\n * @author Stanislav Kalashnik <darkpark.main@gmail.com>\n */\n\n/* eslint no-path-concat: 0 */\n\n'use strict';\n\n\n/**\n * Base Events Emitter implementation.\n *\n * @see http://nodejs.org/api/events.html\n * @constructor\n *\n * @example\n * var emitter = new Emitter();\n */\nfunction Emitter () {\n    console.assert(typeof this === 'object', 'must be constructed via new');\n\n    // if ( DEVELOP ) {\n    //     if ( typeof this !== 'object' ) { throw new Error(__filename + ': must be constructed via new'); }\n    // }\n\n    /**\n     * Inner hash table for event names and linked callbacks.\n     * Manual editing should be avoided.\n     *\n     * @member {Object.<string, function[]>}\n     *\n     * @example\n     * {\n     *     click: [\n     *         function click1 () { ... },\n     *         function click2 () { ... }\n     *     ],\n     *     keydown: [\n     *         function () { ... }\n     *     ]\n     * }\n     **/\n    this.events = {};\n}\n\n\nEmitter.prototype = {\n    /**\n     * Bind an event to the given callback function.\n     * The same callback function can be added multiple times for the same event name.\n     *\n     * @param {string} name event identifier\n     * @param {function} callback function to call on this event\n     *\n     * @example\n     * emitter.addListener('click', function ( data ) { ... });\n     * // one more click handler\n     * emitter.addListener('click', function ( data ) { ... });\n     */\n    addListener: function ( name, callback ) {\n        console.assert(arguments.length === 2, 'wrong arguments number');\n        console.assert(typeof name === 'string', 'wrong name type');\n        console.assert(name.length > 0, 'empty name');\n        console.assert(typeof callback === 'function', 'callback should be a function');\n\n        // if ( DEVELOP ) {\n        //     if ( arguments.length !== 2 ) { throw new Error(__filename + ': wrong arguments number'); }\n        //     if ( typeof name !== 'string' || name.length === 0 ) { throw new Error(__filename + ': wrong or empty name'); }\n        //     if ( typeof callback !== 'function' ) { throw new Error(__filename + ': wrong callback type'); }\n        // }\n\n        // initialization may be required\n        this.events[name] = this.events[name] || [];\n        // append this new event to the list\n        this.events[name].push(callback);\n    },\n\n\n    /**\n     * Add a one time listener for the event.\n     * This listener is invoked only the next time the event is fired, after which it is removed.\n     *\n     * @param {string} name event identifier\n     * @param {function} callback function to call on this event\n     *\n     * @example\n     * emitter.once('click', function ( data ) { ... });\n     */\n    once: function ( name, callback ) {\n        // current execution context\n        var self = this;\n\n        if ( DEVELOP ) {\n            if ( arguments.length !== 2 ) {\n                throw new Error(__filename + ': wrong arguments number');\n            }\n            if ( typeof name !== 'string' || name.length === 0 ) {\n                throw new Error(__filename + ': wrong or empty name');\n            }\n            if ( typeof callback !== 'function' ) {\n                throw new Error(__filename + ': wrong callback type');\n            }\n        }\n\n        // initialization may be required\n        this.events[name] = this.events[name] || [];\n        // append this new event to the list\n        this.events[name].push(function onceWrapper () {\n            self.removeListener(name, onceWrapper);\n            callback.apply(self, arguments);\n        });\n    },\n\n\n    /**\n     * Apply multiple listeners at once.\n     *\n     * @param {Object} callbacks event names with callbacks\n     *\n     * @example\n     * emitter.addListeners({\n     *     click: function ( data ) {},\n     *     close: function ( data ) {}\n     * });\n     */\n    addListeners: function ( callbacks ) {\n        var name;\n\n        if ( DEVELOP ) {\n            if ( arguments.length !== 1 ) {\n                throw new Error(__filename + ': wrong arguments number');\n            }\n            if ( typeof callbacks !== 'object' ) {\n                throw new Error(__filename + ': wrong callbacks type');\n            }\n            if ( Object.keys(callbacks).length === 0 ) {\n                throw new Error(__filename + ': no callbacks given');\n            }\n        }\n\n        for ( name in callbacks ) {\n            if ( callbacks.hasOwnProperty(name) ) {\n                this.addListener(name, callbacks[name]);\n            }\n        }\n    },\n\n\n    /**\n     * Remove all instances of the given callback.\n     *\n     * @param {string} name event identifier\n     * @param {function} callback function to remove\n     *\n     * @example\n     * emitter.removeListener('click', func1);\n     */\n    removeListener: function ( name, callback ) {\n        if ( DEVELOP ) {\n            if ( arguments.length !== 2 ) {\n                throw new Error(__filename + ': wrong arguments number');\n            }\n            if ( typeof name !== 'string' || name.length === 0 ) {\n                throw new Error(__filename + ': wrong or empty name');\n            }\n            if ( typeof callback !== 'function' ) {\n                throw new Error(__filename + ': wrong callback type');\n            }\n            if ( this.events[name] && !Array.isArray(this.events[name]) ) {\n                throw new Error(__filename + ': corrupted inner data');\n            }\n        }\n\n        // the event exists and should have some callbacks\n        if ( this.events[name] ) {\n            // rework the callback list to exclude the given one\n            this.events[name] = this.events[name].filter(function callbacksFilter ( fn ) { return fn !== callback; });\n            // event has no more callbacks so clean it\n            if ( this.events[name].length === 0 ) {\n                // as if there were no listeners at all\n                this.events[name] = undefined;\n            }\n        }\n    },\n\n\n    /**\n     * Remove all callbacks for the given event name.\n     * Without event name clears all events.\n     *\n     * @param {string} [name] event identifier\n     *\n     * @example\n     * emitter.removeAllListeners('click');\n     * emitter.removeAllListeners();\n     *\n     * @deprecated\n     */\n    /*removeAllListeners: function ( name ) {\n        if ( DEVELOP ) {\n            if ( arguments.length !== 0 && (typeof name !== 'string' || name.length === 0) ) {\n                throw new Error(__filename + ': wrong or empty name');\n            }\n        }\n\n        // check input\n        if ( arguments.length === 0 ) {\n            // no arguments so remove everything\n            this.events = {};\n        } else if ( name ) {\n            if ( DEVELOP ) {\n                if ( this.events[name] ) { throw new Error(__filename + ': event is not removed'); }\n            }\n\n            // only name is given so remove all callbacks for the given event\n            // but object structure modification should be avoided\n            this.events[name] = undefined;\n        }\n    },*/\n\n\n    /**\n     * Execute each of the listeners in the given order with the supplied arguments.\n     *\n     * @param {string} name event identifier\n     *\n     * @example\n     * emitter.emit('init');\n     * emitter.emit('click', {src: panel1, dst: panel2});\n     * emitter.emit('load', error, data);\n     *\n     * // it's a good idea to emit event only when there are some listeners\n     * if ( this.events['click'] ) {\n     *     this.emit('click', {event: event});\n     * }\n     */\n    emit: function ( name ) {\n        var event = this.events[name],\n            index;\n\n        if ( DEVELOP ) {\n            if ( arguments.length < 1 ) {\n                throw new Error(__filename + ': wrong arguments number');\n            }\n            if ( typeof name !== 'string' || name.length === 0 ) {\n                throw new Error(__filename + ': wrong or empty name');\n            }\n        }\n\n        // the event exists and should have some callbacks\n        if ( event ) {\n            if ( DEVELOP ) {\n                if ( !Array.isArray(event) ) {\n                    throw new Error(__filename + ': wrong event type');\n                }\n            }\n\n            for ( index = 0; index < event.length; index++ ) {\n                if ( DEVELOP ) {\n                    if ( typeof event[index] !== 'function' ) {\n                        throw new Error(__filename + ': wrong event callback type');\n                    }\n                }\n\n                // invoke the callback with parameters\n                event[index].apply(this, Array.prototype.slice.call(arguments, 1));\n            }\n        }\n    }\n};\n\n\n// correct constructor name\nEmitter.prototype.constructor = Emitter;\n\n\n// public\nmodule.exports = Emitter;\n","/**\n * Created by harry on 28.04.17.\n */\n\n'use strict';\n\nmodule.exports = {\n    data: {},\n    favoriteList: []\n};\n","/**\n *  TV - channels plugin or system module implementation.\n *  Same interface with tv provider from embedded magcore.\n *\n *  events list\n *  antennaPower state\n *  epg:update\n *  channels:update\n *  scanning:start\n *  scanning:stop\n */\n\n'use strict';\n\n/* eslint quote-props: 0 */\n\nvar Emitter        = require('cjs-emitter'),\n    gettextWrapper = require('mag-gettext'),\n\n    Channel        = require('./channel.class.js'),\n    storage        = require('./storage'),\n\n    instanceList   = [],\n    channelList    = [],\n    types          = {},\n    supportedTypes = [],\n\n    antennaStart = false,\n    firstLoad = true,\n\n    api, eventFunction, dataMap,\n    globalEvent, gettext;\n\n\nfunction loadChannels () {\n    var data = dvbManager.GetChannelList(),\n        channels = [],\n        number = 0,\n        index;\n\n    channelList = [];\n    if ( data === '' || data === '{}' ) {\n        return;\n    }\n\n    try {\n        channels = JSON.parse(data).channels;\n    } catch ( error ) {\n        console.log(error);\n\n        return;\n    }\n\n    for ( index = 0; index < channels.length; index++ ) {\n        channels[index]['channel_number'] = parseInt(channels[index]['channel_number'], 10);\n        if ( channels[index].channel_number ) {\n            number = channels[index].channel_number;\n        } else {\n            number++;\n        }\n        channelList.push(new Channel({\n            name: channels[index].name,\n            number: number,\n            id: channels[index].id,\n            url: 'dvb://' + channels[index].id,\n            solution: 'dvb',\n            scrambled: channels[index].scrambled === 'true',\n            genre: {},\n            'monitoring_status': true\n        }));\n    }\n}\n\n\nfunction init ( config ) {\n    storage.data = config.storage;\n    storage.favoriteList = storage.data.getItem('favoriteList') || [];\n    firstLoad = false;\n}\n\n\nfunction initData () {\n    var data = dvbManager.GetChannelList(),\n        powerOfTime = 60 * 2 * 1000;\n\n    try {\n        data = JSON.parse(dvbManager.GetSupportedScanTypes());\n    } catch ( error ) {\n        data = [];\n        console.log(error);\n    }\n\n    supportedTypes = data;\n    types = {};\n    data.forEach(function ( item ) {\n        types[item.name] = item.type;\n    });\n\n    try {\n        data = JSON.parse(dvbManager.GetCurrentScanTypes());\n    } catch ( error ) {\n        data = [];\n        console.log(error);\n    }\n\n    dataMap = data.map(function ( item ) {\n        return item.name;\n    });\n\n    globalEvent = function ( event ) {\n        switch ( event.code ) {\n            // epg update global event\n            case 42:\n                instanceList.forEach(function ( item ) { item.emit('epg:update'); });\n                break;\n            // detected passive antenna type\n            case 43:\n                if ( antennaStart ) {\n                    antennaStart = false;\n                } else {\n                    core.notify({\n                        title: gettext('Detected passive antenna type'),\n                        icon: 'alert',\n                        type: 'warning'\n                    });\n                    instanceList.forEach(function ( item ) { item.emit('antennaPower', false); });\n                }\n                break;\n        }\n    };\n\n    stbEvent.addListener('media', globalEvent);\n    if ( dataMap.indexOf('DVB-T') !== -1 || dataMap.indexOf('DVB-T2') !== -1 ) {\n        dvbManager.SetAntennaPower(true, 0);\n        antennaStart = true;\n        setTimeout(function () {\n            antennaStart = false;\n        }, powerOfTime);\n    }\n}\n\n\nfunction changeAntennaPower ( state ) {\n    if ( dataMap.indexOf('DVB-T') !== -1 ||  dataMap.indexOf('DVB-T2') !== -1  ) {\n        dvbManager.SetAntennaPower(state, 0);\n        instanceList.forEach(function ( item ) { item.emit('antennaPower', state); });\n    }\n}\n\n\nfunction build () {\n    var check,\n        // add = false,\n        data = {\n            id: 'dvb',\n            name: gettext('DVB'),\n            description: gettext('Setting the digital television parameters'),\n            icon: 'theme-icon-DVB',\n            sections: [\n                {\n                    id: 'dvb',\n                    name: gettext('DVB'),\n                    description: gettext('Setting the digital television parameters'),\n                    icon: 'theme-icon-DVB',\n                    parent: 'system'\n                }\n            ],\n            options: [],\n            content: []\n        },\n        antenna = {\n            id: 'dvbSignal',\n            name: gettext('Antenna type'),\n            description: gettext('Set the antenna type: active or passive'),\n            icon: 'theme-icon-dvb-power-on',\n            render: api.renders.toggle,\n            saveImmediate: true,\n            environment: {},\n            prepareForRender: function ( environment, callback ) {\n                callback(dvbManager.GetAntennaPower());\n            },\n            prepareForSave: function ( value, callback ) {\n                changeAntennaPower(value);\n                callback();\n            },\n            getter: api.getters.environment,\n            saver: api.savers.environment,\n            type: 'option',\n            parent: 'dvb'\n        };\n\n\n    data.options = [\n        {\n            id: 'dvbType',\n            name: gettext('Signal type'),\n            description: gettext('Set the signal type: DVB-T, DVB-H, DVB-T2, DVB-S2'),\n            icon: 'theme-icon-equalizer-3',\n            render: api.renders.popupSelect,\n            saveImmediate: false,\n            requireDeviceReboot: true,\n            environment: {\n                'dvb_type': ''\n            },\n            prepareForRender: function ( environment, callback ) {\n                var opt = [],\n                    key;\n\n                console.log(environment['dvb_type']);\n                if ( environment['dvb_type'] ) {\n                    check = environment['dvb_type'];\n                } else {\n                    check = dataMap[0];\n                }\n\n                console.log(check);\n                for ( key in types ) {\n                    opt.push({\n                        name: key,\n                        value: types[key],\n                        selected: types[key] === check\n                    });\n                }\n\n                callback(opt);\n            },\n            prepareForSave: function ( value, callback ) {\n                this.environment['dvb_type'] = value;\n                // if ( !add && ( value === 'DVB-T' || value === 'DVB-T2' ) ) {\n                //     api.options.add([antenna]);\n                //     add = true;\n                // } else {\n                //     if ( add ) {\n                //         api.options.remove([antenna]);\n                //         add = false;\n                //     }\n                // }\n                // this.requireDeviceReboot = dataMap.indexOf(value) === -1;\n                callback();\n            },\n            getter: api.getters.environment,\n            saver: api.savers.environment,\n            type: 'option',\n            parent: 'dvb'\n        }\n    ];\n\n    if ( dataMap.indexOf('DVB-T') !== -1 ||  dataMap.indexOf('DVB-T2') !== -1  ) {\n        data.options.push(antenna);\n        // add = true;\n    }\n\n    return data;\n}\n\n\nfunction Provider () {\n    var self = this;\n\n    Emitter.call(this);\n\n    this.types = {\n        get supported () {\n            return supportedTypes;\n        },\n        get current () {\n            var data;\n\n            try {\n                data = JSON.parse(dvbManager.GetCurrentScanTypes());\n            } catch ( error ) {\n                data = [];\n                console.log(error);\n            }\n\n            if ( data.length === 0 ) {\n                data = [{name: 'Null', type: null}];\n            }\n\n            return data;\n        }\n    };\n\n    this.scanOptions = {\n        get more () {\n            return self.types.current.types === types['DVB-C'];\n        }\n    };\n}\n\n\nProvider.prototype = Object.create(Emitter.prototype);\nProvider.prototype.constructor = Provider;\n\n\nObject.defineProperty(Provider.prototype, 'antennaPower', {\n    get: function () {\n        return dvbManager.GetAntennaPower();\n    },\n    set: function ( enable ) {\n        if ( dataMap.indexOf('DVB-T') !== -1 || dataMap.indexOf('DVB-T2') !== -1 ) {\n            dvbManager.SetAntennaPower(enable, 0);\n            instanceList.forEach(function ( item ) {\n                item.emit('antennaPower', enable);\n            });\n        }\n    }\n});\n\n\n/**\n * Get channel list.\n *\n * @param {Object} [config] - filters configuration\n * @param {Function} callback - result handler\n */\nProvider.prototype.getChannels = function ( config, callback ) {\n    var result = channelList,\n        regExp;\n\n    config = config || {};\n    if ( config.favorite ) {\n        result = result.filter(function ( channel ) {\n            return !!channel.favorite;\n        });\n    }\n\n    if ( config.byName ) {\n        result = result.sort(function ( ai, bi ) {\n            return ai.name > bi.name ? 1 : -1;\n        });\n    } else {\n        result = result.sort(function ( ai, bi ) {\n            return ai.number > bi.number ? 1 : -1;\n        });\n    }\n\n    if ( config.search ) {\n        regExp = new RegExp(config.search, 'i');\n        result = result.filter(function ( channel ) {\n            var match = channel.name.match(regExp);\n\n            return match && match.length;\n        });\n    }\n\n    callback(false, result);\n};\n\n\nProvider.prototype.updateChannelsList = function ( callback ) {\n    loadChannels();\n    this.getChannels(null, callback);\n};\n\n\nProvider.prototype.getLastChannelId = function ( callback ) {\n    callback(false, storage.data.getItem('lastChannel'));\n};\n\n\nProvider.prototype.getCurrentChannelsEpg = function ( channels, callback ) {\n    var map = {};\n\n    channels.forEach(function ( channel ) { map[channel.id] = channel.getEPGBrief(); });\n    callback(false, map);\n};\n\n\nProvider.prototype.getChannelsEpg = function ( config, callback ) {\n    var map = {},\n        channels;\n\n    config = config || {};\n\n    channels = config.channels || [];\n\n\n    if ( !config.from && !config.to ) {\n        channels.forEach(function ( channel ) { map[channel.id] = channel.getEPGBrief(); });\n        callback(false, map);\n    } else {\n        config.from = Math.round(config.from / 1000) || '';\n        config.to  = Math.round(config.to / 1000) || '';\n        channels.forEach(function ( channel ) { map[channel.id] = channel.getEpg(config); });\n        callback(false, map);\n    }\n};\n\n\nfunction autoScan ( config ) {\n    config.input = config.input || 0;\n    config.callbacks = config.callbacks || {};\n    if ( config.type === types['DVB-C'] ) {\n        dvbManager.SetScanParams(JSON.stringify({\n            type: config.type,\n            symRate: config.symRate,\n            modulation: config.modulation,\n            scanMode: 0,\n            networkId: 0\n        }));\n    }\n    dvbManager.StopChannelScan();\n\n    eventFunction = function ( event ) {\n        switch ( event.code ) {\n            case 40:\n                if ( event.info.state && event.info.state === 'finished' ) {\n                    stbEvent.removeListener('media', eventFunction);\n                    eventFunction = null;\n                    if ( config.callbacks.onEnd ) {\n                        config.callbacks.onEnd(event.info);\n                    }\n                    loadChannels();\n                    instanceList.forEach(function ( item ) { item.emit('scanning:end'); });\n                    instanceList.forEach(function ( item ) { item.emit('channels:update'); });\n                } else if ( config.callbacks.onProgress ) {\n                    config.callbacks.onProgress(event.info);\n                }\n                break;\n            case 41:\n                if ( config.callbacks.onFound ) {\n                    config.callbacks.onFound(event.info);\n                }\n                break;\n        }\n    };\n    stbEvent.addListener('media', eventFunction);\n    dvbManager.StartChannelScan(config.type);\n\n    instanceList.forEach(function ( item ) { item.emit('scanning:start'); });\n\n    return true;\n}\n\n\n/**\n * Start auto scanning.\n *\n * @param {Object} config - scan configuration\n * @param {string} config.type - DVB type\n * @param {Object} config.callbacks - callback functions on event\n * @param {Function} config.callbacks.onProgress - progress callback function\n * @param {Function} config.callbacks.onFound - channel found callback function\n * @param {Function} config.callbacks.onEnd - channel scan was ended callback function\n * @param {number} [config.symRate] - symbol rate only for DVB-C\n * @param {number} [config.modulation] - modulation only for DVB-C\n * @param {number} [config.input] - input index default 0\n *\n * @return {boolean} scanning start\n */\nProvider.prototype.startAutoScan = function ( config ) {\n    if ( eventFunction ) {\n        return false;\n    }\n    dvbManager.ClearChannelList();\n    channelList = [];\n\n    return autoScan(config);\n};\n\n\nfunction manualScan ( config ) {\n    config.input = config.input || 0;\n    config.callbacks = config.callbacks || {};\n    dvbManager.StopChannelScan();\n\n    eventFunction = function ( event ) {\n        switch ( event.code ) {\n            case 40:\n                if ( event.info.state && event.info.state === 'finished' ) {\n                    stbEvent.removeListener('media', eventFunction);\n                    eventFunction = null;\n\n                    if ( config.callbacks.onEnd ) {\n                        config.callbacks.onEnd(event.info);\n                    }\n\n                    loadChannels();\n                    instanceList.forEach(function ( item ) {\n                        item.emit('scanning:end');\n                    });\n                    instanceList.forEach(function ( item ) {\n                        item.emit('channels:update');\n                    });\n                } else if ( config.callbacks.onProgress ) {\n                    config.callbacks.onProgress(event.info);\n                }\n                break;\n            case 41:\n                if ( config.callbacks.onFound ) {\n                    config.callbacks.onFound(event.info);\n                }\n                break;\n        }\n    };\n    stbEvent.addListener('media', eventFunction);\n\n    if ( config.type === types['DVB-C'] ) {\n        config.netId = config.netId || 0;\n        dvbManager.SetScanParams(JSON.stringify({\n            type: config.type,\n            symRate: config.symRate,\n            modulation: config.modulation,\n            scanMode: 2,\n            frequency: config.frequency,\n            networkId: config.netId\n        }));\n        dvbManager.StartChannelScan(config.type);\n    } else {\n        dvbManager.StartChannelScanManual(config.frequency, config.frequencyEnd, config.type, config.band ? config.band : 8, 1000);\n    }\n}\n\n\n/**\n * Start manual scanning.\n *\n * @param {Object} config - scan configuration\n * @param {string} config.type - DVB type\n * @param {Object} config.callbacks - callback functions on event\n * @param {Function} config.callbacks.onProgress - progress callback function\n * @param {Function} config.callbacks.onFound - channel found callback function\n * @param {Function} config.callbacks.onEnd - channel scan was ended callback function\n * @param {number} [config.symRate] - symbol rate only for DVB-C\n * @param {number} [config.modulation] - modulation only for DVB-C\n * @param {number} [config.input] - input index default 0\n * @param {number} [config.netId] - Network ID only for DVB-C\n * @param {number} config.frequency - frequency start ( or frequency only for DVB-C )\n * @param {number} [config.frequencyEnd] - frequency end not supported for DVB-C\n * @param {number} [config.band] - bandwidth\n *\n * @return {boolean} scanning start\n */\nProvider.prototype.startManualScan = function ( config ) {\n    if ( eventFunction ) {\n        return false;\n    }\n    dvbManager.ClearChannelList();\n    channelList = [];\n\n    return manualScan(config);\n};\n\n\n/**\n * Remove all channels.\n */\nProvider.prototype.clearList = function () {\n    if ( dvbManager.ClearChannelList() === 0 ) {\n        loadChannels();\n        instanceList.forEach(function ( item ) { item.emit('channels:update'); });\n    }\n};\n\n\n/**\n * Stop scanning.\n */\nProvider.prototype.stopScan = function () {\n    if ( eventFunction ) {\n        stbEvent.removeListener('media', eventFunction);\n        eventFunction = null;\n    }\n    dvbManager.StopChannelScan();\n    loadChannels();\n    instanceList.forEach(function ( item ) { item.emit('scanning:stop'); });\n};\n\n\n/**\n * Destroy and remove this instance from instance list.\n */\nProvider.prototype.destroy = function () {\n    var index = instanceList.indexOf(this);\n\n    if ( index !== -1 ) {\n        instanceList = instanceList.splice(index, 1);\n    }\n};\n\n\nmodule.exports = {\n    onAppInit: function ( config, callback ) {\n        var provider = new Provider();\n\n        if ( firstLoad ) {\n            init(config);\n        }\n\n        instanceList.push(provider);\n        callback(null, provider);\n    },\n    onInit: function ( config, callback ) {\n        initData();\n        callback();\n    },\n    onSettingsInit: function ( config, callback ) {\n        api = config.api;\n\n        gettextWrapper.load({\n            name: core.environment.language,\n            path: config.path + 'lang'\n        }, function () {\n            gettext = gettextWrapper.gettext;\n            callback(null, build());\n        });\n    }\n};\n","/**\n * @license The MIT License (MIT)\n * @copyright Stanislav Kalashnik <darkpark.main@gmail.com>\n */\n\n/* eslint no-path-concat: 0 */\n\n'use strict';\n\nvar Emitter = require('cjs-emitter'),\n    Gettext = require('cjs-gettext'),\n    loader  = new Emitter();\n\n\nif ( DEVELOP ) {\n    loader._ = loader.gettext = loader.pgettext = loader.ngettext = function () {\n        throw new Error(__filename + ': you cannot use this function before mag-gettext not yet loaded');\n    };\n}\n\n/**\n * Wrap the given data with gettext instance\n * and export methods to the global scope.\n *\n * @param {Object} [data] localization data\n */\nfunction prepare ( data ) {\n    var gettext = new Gettext(data);\n\n    loader._ = loader.gettext = gettext.gettext;\n    loader.pgettext = gettext.pgettext;\n    loader.ngettext = gettext.ngettext;\n}\n\n\n/**\n * Main application language\n */\nloader.defaultLanguage = 'en';\n\n\n/**\n * Simple gettext implementation.\n *\n * @param {Object} config options\n * @param {string} [config.path=lang] relative path to project root\n * @param {string} config.name language name\n * @param {string} [config.ext=json] language file extension\n * @param {function} callback hook on ready\n */\nloader.load = function ( config, callback ) {\n    var xhr;\n\n    if ( DEVELOP ) {\n        if ( !config.name || typeof config.name !== 'string' ) {\n            throw new Error(__filename + ': config.name must be a nonempty string');\n        }\n        if ( callback && typeof callback !== 'function' ) {\n            throw new Error(__filename + ': wrong callback type');\n        }\n    }\n\n    // defaults\n\n    callback = callback || null;\n    config.ext  = config.ext  || 'json';\n    config.path = config.path || 'lang';\n\n    // is it necessary to request a localization file?\n    if ( config.name === loader.defaultLanguage ) {\n        // no\n        prepare();\n        if ( callback !== null ) {\n            callback(null);\n        }\n    } else {\n        xhr = new XMLHttpRequest();\n\n        xhr.onload = function () {\n            var jsonParseError, json;\n\n            try {\n                json = JSON.parse(xhr.responseText);\n            } catch ( error ) {\n                jsonParseError = error;\n            }\n\n            if ( jsonParseError ) {\n                xhr.onerror(jsonParseError);\n            } else {\n                prepare(json);\n                if ( callback !== null ) {\n                    callback(null);\n                }\n\n                // there are some listeners\n                if ( loader.events['load'] ) {\n                    // notify listeners\n                    loader.emit('load');\n                }\n            }\n        };\n\n        xhr.ontimeout = xhr.onerror = function ( error ) {\n            prepare();\n\n            if ( callback !== null ) {\n                callback(null);\n            }\n\n            // there are some listeners\n            if ( loader.events['error'] ) {\n                // notify listeners\n                loader.emit('error', error);\n            }\n        };\n\n        xhr.open('GET', config.path + '/' + config.name + '.' + config.ext, true);\n        xhr.send(null);\n    }\n};\n\n\n// public\nmodule.exports = loader;\n","/**\n * @license The MIT License (MIT)\n * @author Stanislav Kalashnik <darkpark.main@gmail.com>\n */\n\n/* eslint no-path-concat: 0 */\n\n'use strict';\n\n\n/**\n * Translations handler.\n *\n * @constructor\n *\n * @param {Object} config init parameters\n */\nfunction Gettext ( config ) {\n    var data, meta;\n\n    // sanitize\n    config   = config || {};\n    data     = config.data || {};\n    data[''] = data[''] || {};\n\n    // shortcut\n    meta = config.meta;\n\n    /**\n     * Display the native language translation of a textual message.\n     *\n     * @param {string} msgId textual message\n     *\n     * @return {string} translated text\n     */\n    this.gettext = function ( msgId ) {\n        return data[''][msgId] || msgId;\n    };\n\n\n    /**\n     * The \"p\" in \"pgettext\" stands for \"particular\": fetches a particular translation of the textual message.\n     *\n     * @param {string} context message context\n     * @param {string} msgId textual message\n     *\n     * @return {string} translated text\n     */\n    this.pgettext = function ( context, msgId ) {\n        return data[context] && data[context][msgId] || msgId;\n    };\n\n\n    /**\n     * Display the native language translation of a textual message whose grammatical form depends on a number.\n     *\n     * @param {string} msgId textual message in a singular form\n     * @param {string} plural textual message in a plural form\n     * @param {number} value message number\n     *\n     * @return {string} translated text\n     */\n    this.ngettext = function ( msgId, plural, value ) {\n        /* eslint no-unused-vars: 0 */\n        /* eslint no-eval: 0 */\n        /* eslint id-length: 0 */\n        var n, evalResult;\n\n        if ( DEVELOP ) {\n            if ( Number(value) !== value ) {\n                throw new Error(__filename + ': value must be a number');\n            }\n        }\n\n        if ( data && meta && data[''][msgId] ) {\n            evalResult = eval('n = ' + value + '; ' + meta.plural);\n\n            if ( typeof evalResult === 'boolean' ) {\n                evalResult = +evalResult;\n            }\n\n            // translation\n            return data[''][msgId][evalResult];\n        }\n\n        // english\n        return value === 1 ? msgId : plural;\n    };\n}\n\n\n// correct constructor name\nGettext.prototype.constructor = Gettext;\n\n\n// public\nmodule.exports = Gettext;\n","'use strict';\n\nvar storage = require('./storage'),\n    Epg = require('./epg.class.js');\n\n\nfunction Channel ( config ) {\n    var key;\n\n    config = config || {};\n\n    for ( key in config ) {\n        this[key] = config[key];\n    }\n    this.favorite = storage.favoriteList.indexOf(this.id) !== -1;\n}\n\n\n/**\n * Toggle favorite state\n *\n * @param {Function} callback - callback after toggle\n */\nChannel.prototype.toggleFavorite = function ( callback ) {\n    var index;\n\n    this.favorite = !this.favorite;\n\n    if ( this.favorite ) {\n        storage.favoriteList.push(this.id);\n    } else {\n        index = storage.favoriteList.indexOf(this.id);\n        if ( index !== -1 ) {\n            storage.favoriteList.splice(index, 1);\n        }\n    }\n\n    storage.data.setItem('favoriteList', storage.favoriteList);\n    callback(false, this.favorite);\n};\n\n\nChannel.prototype.getUrl = function ( callback ) {\n    callback(false, {url: this.url, solution: this.solution});\n};\n\n\nChannel.prototype.getEpg = function ( config, callback ) {\n    var data,\n        result = [],\n        now = new Date(),\n        from, to, index;\n\n    config = config || {};\n\n    // use 7 days before current and next 7 days to get epg\n    from = +new Date(now.getFullYear(), now.getMonth(), now.getDate() - 7);\n    to =  +new Date(now.getFullYear(), now.getMonth(), now.getDate() + 7);\n    from = Math.round(from / 1000);\n    to  = Math.round(to / 1000);\n\n    from = config.from || from;\n    to = config.to || to;\n\n    try {\n        data = dvbManager.GetEPGScheduleByRange(this.id, from, to);\n        if ( data === '' || data === '{}' ) {\n            if ( callback ) {\n                callback(false, []);\n            }\n\n            return result;\n        }\n        data = JSON.parse(data);\n    } catch ( error ) {\n        console.log(error);\n        if ( callback ) {\n            callback(error, []);\n        }\n\n        return result;\n    }\n\n    for ( index = 0; index < data.events.length; index++ ) {\n        data.events[index].channel = this;\n        result.push(new Epg(data.events[index]));\n    }\n    if ( callback ) {\n        callback(false, result);\n    }\n\n    return result;\n};\n\n\nChannel.prototype.getEPGBrief = function ( callback ) {\n    var data = dvbManager.GetEPGBrief(this.id),\n        result;\n\n    if ( data === '' || data === '{}' ) {\n        if ( callback ) {\n            callback(true);\n        }\n\n        return null;\n    }\n\n    try {\n        data = JSON.parse(data);\n    } catch ( error ) {\n        console.log(error);\n        if ( callback ) {\n            callback(true);\n        }\n\n        return null;\n    }\n\n    if ( !data.events || data.events.length === 0 ) {\n        if ( callback ) {\n            callback(true);\n        }\n\n        return null;\n    }\n\n    data.events[0].channel = this;\n    result = new Epg(data.events[0]);\n    if ( callback ) {\n        callback(false, result);\n    }\n\n    return result;\n};\n\n\nChannel.prototype.setLast = function () {\n    storage.data.setItem('lastChannel', this.id);\n};\n\n\nChannel.prototype.remove = function () {\n    dvbManager.RemoveChannel(this.id);\n};\n\n\nmodule.exports = Channel;\n","'use strict';\n\nmodule.exports = function ( config ) {\n    config = config || {};\n\n    /**\n     * Is epg can be downloaded.\n     */\n    this.downloadable = false;\n\n    /**\n     * Start time ms.\n     */\n    this.start = config.start;\n\n    /**\n     * End time ms.\n     */\n    this.end = config.start + config.duration;\n\n    /**\n     * Epg title.\n     */\n    this.title = config.name;\n\n    this.id = null;\n\n    /**\n     * Is epg in archive.\n     */\n    this.archive = false;\n\n    /**\n     * Link to channel.\n     */\n    this.channel = config.channel;\n\n    this.info = config.info;\n    this.duration = config.duration;\n    this.details = config.details;\n};\n"],"sourceRoot":""}
{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/cjs-emitter/index.js","webpack:///./src/js/main.js","webpack:///./node_modules/mag-gettext/index.js","webpack:///./node_modules/cjs-gettext/index.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","Emitter","this","events","addListener","callback","push","once","self","onceWrapper","removeListener","apply","arguments","addListeners","callbacks","filter","fn","length","undefined","emit","index","event","Array","slice","constructor","timerId","gettext","gettextWrapper","plugin","downloads","hash","updateTime","errors","wrongUrl","code","message","wrongFileName","fileAlreadyExist","failedToCreateTask","wrongDownloadItem","wrongPathToStorage","update","rawData","item","progress","JSON","parse","stbDownloadManager","GetQueueInfo","error","state","Number","id","states","PERMANENT_ERROR","TEMPORARY_ERROR","progressPct","Math","ceil","RUNNING","data","indexOf","time","Date","now","filePath","path","mountPoint","priority","prio","size","sizeTotal","url","attempt","priorityLevel","prioLevel","sizeDone","tempFile","timeWasted","pause","StopJob","resume","StartJob","STOPPED","WAITING","FINISHED","add","gSTB","IsFileExist","AddJob","remove","deleteFile","DeleteJob","splice","restore","RestoreJobs","validate","storages","trashStorages","realStorages","trashTasks","GetStorageInfo","result","mountPath","forEach","pathToCatalog","InvalidateCatalog","defineProperties","list","updateInterval","set","newTime","clearInterval","setInterval","reset","onInit","config","load","window","core","environment","language","onAppInit","Gettext","loader","prepare","_","pgettext","ngettext","defaultLanguage","xhr","ext","XMLHttpRequest","onload","jsonParseError","json","responseText","onerror","ontimeout","open","send","meta","msgId","context","plural","evalResult","eval"],"mappings":"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","file":"main.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","/**\n * @license The MIT License (MIT)\n * @author Stanislav Kalashnik <darkpark.main@gmail.com>\n */\n\n/* eslint no-path-concat: 0 */\n\n'use strict';\n\n\n/**\n * Base Events Emitter implementation.\n *\n * @see http://nodejs.org/api/events.html\n * @constructor\n *\n * @example\n * var emitter = new Emitter();\n */\nfunction Emitter () {\n    console.assert(typeof this === 'object', 'must be constructed via new');\n\n    // if ( DEVELOP ) {\n    //     if ( typeof this !== 'object' ) { throw new Error(__filename + ': must be constructed via new'); }\n    // }\n\n    /**\n     * Inner hash table for event names and linked callbacks.\n     * Manual editing should be avoided.\n     *\n     * @member {Object.<string, function[]>}\n     *\n     * @example\n     * {\n     *     click: [\n     *         function click1 () { ... },\n     *         function click2 () { ... }\n     *     ],\n     *     keydown: [\n     *         function () { ... }\n     *     ]\n     * }\n     **/\n    this.events = {};\n}\n\n\nEmitter.prototype = {\n    /**\n     * Bind an event to the given callback function.\n     * The same callback function can be added multiple times for the same event name.\n     *\n     * @param {string} name event identifier\n     * @param {function} callback function to call on this event\n     *\n     * @example\n     * emitter.addListener('click', function ( data ) { ... });\n     * // one more click handler\n     * emitter.addListener('click', function ( data ) { ... });\n     */\n    addListener: function ( name, callback ) {\n        console.assert(arguments.length === 2, 'wrong arguments number');\n        console.assert(typeof name === 'string', 'wrong name type');\n        console.assert(name.length > 0, 'empty name');\n        console.assert(typeof callback === 'function', 'callback should be a function');\n\n        // if ( DEVELOP ) {\n        //     if ( arguments.length !== 2 ) { throw new Error(__filename + ': wrong arguments number'); }\n        //     if ( typeof name !== 'string' || name.length === 0 ) { throw new Error(__filename + ': wrong or empty name'); }\n        //     if ( typeof callback !== 'function' ) { throw new Error(__filename + ': wrong callback type'); }\n        // }\n\n        // initialization may be required\n        this.events[name] = this.events[name] || [];\n        // append this new event to the list\n        this.events[name].push(callback);\n    },\n\n\n    /**\n     * Add a one time listener for the event.\n     * This listener is invoked only the next time the event is fired, after which it is removed.\n     *\n     * @param {string} name event identifier\n     * @param {function} callback function to call on this event\n     *\n     * @example\n     * emitter.once('click', function ( data ) { ... });\n     */\n    once: function ( name, callback ) {\n        // current execution context\n        var self = this;\n\n        if ( DEVELOP ) {\n            if ( arguments.length !== 2 ) {\n                throw new Error(__filename + ': wrong arguments number');\n            }\n            if ( typeof name !== 'string' || name.length === 0 ) {\n                throw new Error(__filename + ': wrong or empty name');\n            }\n            if ( typeof callback !== 'function' ) {\n                throw new Error(__filename + ': wrong callback type');\n            }\n        }\n\n        // initialization may be required\n        this.events[name] = this.events[name] || [];\n        // append this new event to the list\n        this.events[name].push(function onceWrapper () {\n            self.removeListener(name, onceWrapper);\n            callback.apply(self, arguments);\n        });\n    },\n\n\n    /**\n     * Apply multiple listeners at once.\n     *\n     * @param {Object} callbacks event names with callbacks\n     *\n     * @example\n     * emitter.addListeners({\n     *     click: function ( data ) {},\n     *     close: function ( data ) {}\n     * });\n     */\n    addListeners: function ( callbacks ) {\n        var name;\n\n        if ( DEVELOP ) {\n            if ( arguments.length !== 1 ) {\n                throw new Error(__filename + ': wrong arguments number');\n            }\n            if ( typeof callbacks !== 'object' ) {\n                throw new Error(__filename + ': wrong callbacks type');\n            }\n            if ( Object.keys(callbacks).length === 0 ) {\n                throw new Error(__filename + ': no callbacks given');\n            }\n        }\n\n        for ( name in callbacks ) {\n            if ( callbacks.hasOwnProperty(name) ) {\n                this.addListener(name, callbacks[name]);\n            }\n        }\n    },\n\n\n    /**\n     * Remove all instances of the given callback.\n     *\n     * @param {string} name event identifier\n     * @param {function} callback function to remove\n     *\n     * @example\n     * emitter.removeListener('click', func1);\n     */\n    removeListener: function ( name, callback ) {\n        if ( DEVELOP ) {\n            if ( arguments.length !== 2 ) {\n                throw new Error(__filename + ': wrong arguments number');\n            }\n            if ( typeof name !== 'string' || name.length === 0 ) {\n                throw new Error(__filename + ': wrong or empty name');\n            }\n            if ( typeof callback !== 'function' ) {\n                throw new Error(__filename + ': wrong callback type');\n            }\n            if ( this.events[name] && !Array.isArray(this.events[name]) ) {\n                throw new Error(__filename + ': corrupted inner data');\n            }\n        }\n\n        // the event exists and should have some callbacks\n        if ( this.events[name] ) {\n            // rework the callback list to exclude the given one\n            this.events[name] = this.events[name].filter(function callbacksFilter ( fn ) { return fn !== callback; });\n            // event has no more callbacks so clean it\n            if ( this.events[name].length === 0 ) {\n                // as if there were no listeners at all\n                this.events[name] = undefined;\n            }\n        }\n    },\n\n\n    /**\n     * Remove all callbacks for the given event name.\n     * Without event name clears all events.\n     *\n     * @param {string} [name] event identifier\n     *\n     * @example\n     * emitter.removeAllListeners('click');\n     * emitter.removeAllListeners();\n     *\n     * @deprecated\n     */\n    /*removeAllListeners: function ( name ) {\n        if ( DEVELOP ) {\n            if ( arguments.length !== 0 && (typeof name !== 'string' || name.length === 0) ) {\n                throw new Error(__filename + ': wrong or empty name');\n            }\n        }\n\n        // check input\n        if ( arguments.length === 0 ) {\n            // no arguments so remove everything\n            this.events = {};\n        } else if ( name ) {\n            if ( DEVELOP ) {\n                if ( this.events[name] ) { throw new Error(__filename + ': event is not removed'); }\n            }\n\n            // only name is given so remove all callbacks for the given event\n            // but object structure modification should be avoided\n            this.events[name] = undefined;\n        }\n    },*/\n\n\n    /**\n     * Execute each of the listeners in the given order with the supplied arguments.\n     *\n     * @param {string} name event identifier\n     *\n     * @example\n     * emitter.emit('init');\n     * emitter.emit('click', {src: panel1, dst: panel2});\n     * emitter.emit('load', error, data);\n     *\n     * // it's a good idea to emit event only when there are some listeners\n     * if ( this.events['click'] ) {\n     *     this.emit('click', {event: event});\n     * }\n     */\n    emit: function ( name ) {\n        var event = this.events[name],\n            index;\n\n        if ( DEVELOP ) {\n            if ( arguments.length < 1 ) {\n                throw new Error(__filename + ': wrong arguments number');\n            }\n            if ( typeof name !== 'string' || name.length === 0 ) {\n                throw new Error(__filename + ': wrong or empty name');\n            }\n        }\n\n        // the event exists and should have some callbacks\n        if ( event ) {\n            if ( DEVELOP ) {\n                if ( !Array.isArray(event) ) {\n                    throw new Error(__filename + ': wrong event type');\n                }\n            }\n\n            for ( index = 0; index < event.length; index++ ) {\n                if ( DEVELOP ) {\n                    if ( typeof event[index] !== 'function' ) {\n                        throw new Error(__filename + ': wrong event callback type');\n                    }\n                }\n\n                // invoke the callback with parameters\n                event[index].apply(this, Array.prototype.slice.call(arguments, 1));\n            }\n        }\n    }\n};\n\n\n// correct constructor name\nEmitter.prototype.constructor = Emitter;\n\n\n// public\nmodule.exports = Emitter;\n","/**\n * MAGSDK basic implementation of downloads plugin.\n *\n * @author <bas.jsdev@gmail.com>\n */\n\n'use strict';\n\n\nvar Emitter        = require('cjs-emitter'),\n    gettextWrapper = require('mag-gettext'),\n    plugin         = new Emitter(),\n    downloads      = [],\n    hash           = {},\n    updateTime     = 2000,\n    errors         = {\n        wrongUrl:           {code: '-1', message: ''},\n        wrongFileName:      {code: '-2', message: ''},\n        fileAlreadyExist:   {code: '-3', message: ''},\n        failedToCreateTask: {code: '-4', message: ''},\n        wrongDownloadItem:  {code: '-5', message: ''},\n        wrongPathToStorage: {code: '-6', message: ''}\n    },\n    timerId, gettext;\n\n\n/**\n * Check for changes. If there are some emit corresponding events.\n */\nfunction update () {\n    var rawData, index, item, progress;\n\n    try {\n        rawData = JSON.parse(stbDownloadManager.GetQueueInfo());\n    } catch ( error ) {\n        rawData = [];\n    }\n\n    for ( index = 0; index < rawData.length; index++ ) {\n        // correct state type\n        rawData[index].state = Number(rawData[index].state);\n        // if new item, trigger event\n        if ( hash[rawData[index].id] ) {\n            item = hash[rawData[index].id];\n            // error task should have 0% progress\n            if (\n                rawData[index].state === plugin.states.PERMANENT_ERROR\n                || rawData[index].state === plugin.states.TEMPORARY_ERROR\n            ) {\n                rawData[index].progressPct = 0;\n            }\n            progress = Math.ceil(rawData[index].progressPct);\n            // check if progress changed (every running task)\n            if ( rawData[index].state === plugin.states.RUNNING && progress !== item.data.progress ) {\n                item.data.progress = progress;\n                downloads[downloads.indexOf(item)].data.progress = progress;\n                if ( plugin.events['progress'] ) {\n                    plugin.emit('progress', {item: item, time: Date.now()});\n                }\n            }\n            // check if state changed\n            if ( rawData[index].state !== item.data.state ) {\n                item.data.state = rawData[index].state;\n                // fix progress bug (can stop at 99% because of long update time)\n                if ( progress !== item.data.progress ) {\n                    item.data.progress = progress;\n                    downloads[downloads.indexOf(item)].data.progress = progress;\n                }\n                downloads[downloads.indexOf(item)].data.state = item.data.state;\n                if ( plugin.events['state'] ) {\n                    plugin.emit('state', {item: item, time: Date.now()});\n                }\n            }\n        } else {\n            item = new Emitter();\n            item.data = {\n                name:          rawData[index].filePath,\n                id:            rawData[index].id,\n                path:          rawData[index].mountPoint,\n                priority:      rawData[index].prio,\n                progress:      Math.ceil(rawData[index].progressPct >= 0 ? rawData[index].progressPct : 0),\n                size:          rawData[index].sizeTotal,\n                state:         rawData[index].state,\n                url:           rawData[index].url,\n                attempt:       rawData[index].attempt,\n                priorityLevel: rawData[index].prioLevel,\n                sizeDone:      rawData[index].sizeDone,\n                tempFile:      rawData[index].tempFile,\n                timeWasted:    rawData[index].timeWasted\n            };\n            // error task should have 0% progress\n            if (\n                item.data.state === plugin.states.PERMANENT_ERROR\n                || item.data.state === plugin.states.TEMPORARY_ERROR\n            ) {\n                item.data.progress = 0;\n            }\n\n            item.pause = function () {\n                stbDownloadManager.StopJob(this.data.id);\n            };\n\n            item.resume = function () {\n                stbDownloadManager.StartJob(this.data.id);\n            };\n\n            hash[item.data.id] = item;\n            downloads.push(item);\n            if ( plugin.events['add'] ) {\n                plugin.emit('add', {item: item, time: Date.now()});\n            }\n        }\n    }\n}\n\n\n/**\n * Task possible states\n */\nplugin.states = {\n    STOPPED:         0,\n    WAITING:         1,\n    RUNNING:         2,\n    FINISHED:        3,\n    TEMPORARY_ERROR: 4,\n    PERMANENT_ERROR: 5\n};\n\n\nplugin.add = function ( data, callback ) {\n    if ( typeof callback !== 'function' ) {\n        console.log('Wrong callback function.');\n\n        return;\n    }\n    if ( !data.url ) {\n        callback(errors.wrongUrl);\n\n        return;\n    }\n    if ( !data.name ) {\n        callback(errors.wrongFileName);\n\n        return;\n    }\n    if ( gSTB.IsFileExist(data.name) ) {\n        callback(errors.fileAlreadyExist);\n\n        return;\n    }\n    if ( !stbDownloadManager.AddJob(data.url, data.name) ) {\n        callback(errors.failedToCreateTask);\n\n        return;\n    }\n    callback(null, true);\n};\n\n\nplugin.remove = function ( item, deleteFile, callback ) {\n    if ( typeof callback !== 'function' ) {\n        console.log('Wrong callback function.');\n\n        return;\n    }\n    if ( !item || !(item instanceof Emitter) ) {\n        callback(errors.wrongDownloadItem);\n\n        return;\n    }\n    stbDownloadManager.DeleteJob(item.data.id, !!deleteFile);\n    delete hash[item.data.id];\n    downloads.splice(downloads.indexOf(item), 1);\n\n    callback(null, true);\n\n    if ( plugin.events['remove'] ) {\n        plugin.emit('remove', {item: item, time: Date.now()});\n    }\n};\n\n\nplugin.restore = function ( path, callback ) {\n    if ( typeof callback !== 'function' ) {\n        console.log('Wrong callback function.');\n\n        return;\n    }\n    if ( !path ) {\n        callback(errors.wrongPathToStorage);\n\n        return;\n    }\n    stbDownloadManager.RestoreJobs(path);\n\n    callback(null, true);\n\n    if ( plugin.events['restore'] ) {\n        plugin.emit('restore', {time: Date.now()});\n    }\n};\n\n\n// Storage was removed so find and delete tasks connected to this storage.\nplugin.validate = function () {\n    var trashStorages = [],\n        realStorages  = [],\n        trashTasks    = [],\n        storages, index, path;\n\n    //console.log(stbDownloadManager.GetQueueInfo());\n    try {\n        storages = JSON.parse(gSTB.GetStorageInfo('{}'));\n        storages = storages.result;\n    } catch ( error ) {\n        console.log(error);\n        storages = [];\n    }\n\n    for ( index = 0; index < storages.length; index++ ) {\n        realStorages.push(storages[index].mountPath);\n    }\n    for ( index = 0; index < downloads.length; index++ ) {\n        path = downloads[index].data.path;\n        if ( realStorages.indexOf(path) === -1 ) {\n            trashTasks.push(downloads[index]);\n        }\n        if ( realStorages.indexOf(path) === -1 && trashStorages.indexOf(path) === -1 ) {\n            trashStorages.push(path);\n        }\n    }\n    // clean up all bad tasks\n    trashTasks.forEach(function ( item ) {\n        //console.log('delete id: ' + item.data.id);\n        if ( plugin.events['remove'] ) {\n            plugin.emit('remove', {item: item, time: Date.now()});\n        }\n        delete hash[item.data.id];\n        downloads.splice(downloads.indexOf(item), 1);\n    });\n    // clean up all bad storages and trash tasks\n    trashStorages.forEach(function ( pathToCatalog ) {\n        stbDownloadManager.InvalidateCatalog(pathToCatalog);\n    });\n};\n\n\nObject.defineProperties(plugin, {\n    list: {\n        get: function () {\n            return downloads;\n        }\n    },\n    updateInterval: {\n        get: function () {\n            return updateTime;\n        },\n        set: function ( newTime ) {\n            updateTime = newTime;\n            clearInterval(timerId);\n            timerId = setInterval(update, updateTime);\n        }\n    }\n});\n\n\nplugin.reset = function () {\n    downloads = [];\n    hash = {};\n};\n\n\n// first launch\nupdate();\n// check info and trigger events if something happened\ntimerId = setInterval(update, updateTime);\n\n\nmodule.exports = {\n    onInit: function ( config, callback ) {\n        gettextWrapper.load({\n            name: window.core.environment.language,\n            path: config.path + 'lang'\n        }, function () {\n            gettext = gettextWrapper.gettext;\n\n            errors.wrongUrl.message           = gettext('Wrong url.');\n            errors.wrongFileName.message      = gettext('Wrong fileName.');\n            errors.fileAlreadyExist.message   = gettext('File already exist.');\n            errors.failedToCreateTask.message = gettext('Failed to create download.');\n            errors.wrongDownloadItem.message  = gettext('Wrong download item.');\n            errors.wrongPathToStorage.message = gettext('Wrong path to storage.');\n\n            callback();\n        });\n    },\n    onAppInit: function ( config, callback ) {\n        callback(null, plugin);\n    }\n};\n","/**\n * @license The MIT License (MIT)\n * @copyright Stanislav Kalashnik <darkpark.main@gmail.com>\n */\n\n/* eslint no-path-concat: 0 */\n\n'use strict';\n\nvar Emitter = require('cjs-emitter'),\n    Gettext = require('cjs-gettext'),\n    loader  = new Emitter();\n\n\nif ( DEVELOP ) {\n    loader._ = loader.gettext = loader.pgettext = loader.ngettext = function () {\n        throw new Error(__filename + ': you cannot use this function before mag-gettext not yet loaded');\n    };\n}\n\n/**\n * Wrap the given data with gettext instance\n * and export methods to the global scope.\n *\n * @param {Object} [data] localization data\n */\nfunction prepare ( data ) {\n    var gettext = new Gettext(data);\n\n    loader._ = loader.gettext = gettext.gettext;\n    loader.pgettext = gettext.pgettext;\n    loader.ngettext = gettext.ngettext;\n}\n\n\n/**\n * Main application language\n */\nloader.defaultLanguage = 'en';\n\n\n/**\n * Simple gettext implementation.\n *\n * @param {Object} config options\n * @param {string} [config.path=lang] relative path to project root\n * @param {string} config.name language name\n * @param {string} [config.ext=json] language file extension\n * @param {function} callback hook on ready\n */\nloader.load = function ( config, callback ) {\n    var xhr;\n\n    if ( DEVELOP ) {\n        if ( !config.name || typeof config.name !== 'string' ) {\n            throw new Error(__filename + ': config.name must be a nonempty string');\n        }\n        if ( callback && typeof callback !== 'function' ) {\n            throw new Error(__filename + ': wrong callback type');\n        }\n    }\n\n    // defaults\n\n    callback = callback || null;\n    config.ext  = config.ext  || 'json';\n    config.path = config.path || 'lang';\n\n    // is it necessary to request a localization file?\n    if ( config.name === loader.defaultLanguage ) {\n        // no\n        prepare();\n        if ( callback !== null ) {\n            callback(null);\n        }\n    } else {\n        xhr = new XMLHttpRequest();\n\n        xhr.onload = function () {\n            var jsonParseError, json;\n\n            try {\n                json = JSON.parse(xhr.responseText);\n            } catch ( error ) {\n                jsonParseError = error;\n            }\n\n            if ( jsonParseError ) {\n                xhr.onerror(jsonParseError);\n            } else {\n                prepare(json);\n                if ( callback !== null ) {\n                    callback(null);\n                }\n\n                // there are some listeners\n                if ( loader.events['load'] ) {\n                    // notify listeners\n                    loader.emit('load');\n                }\n            }\n        };\n\n        xhr.ontimeout = xhr.onerror = function ( error ) {\n            prepare();\n\n            if ( callback !== null ) {\n                callback(null);\n            }\n\n            // there are some listeners\n            if ( loader.events['error'] ) {\n                // notify listeners\n                loader.emit('error', error);\n            }\n        };\n\n        xhr.open('GET', config.path + '/' + config.name + '.' + config.ext, true);\n        xhr.send(null);\n    }\n};\n\n\n// public\nmodule.exports = loader;\n","/**\n * @license The MIT License (MIT)\n * @author Stanislav Kalashnik <darkpark.main@gmail.com>\n */\n\n/* eslint no-path-concat: 0 */\n\n'use strict';\n\n\n/**\n * Translations handler.\n *\n * @constructor\n *\n * @param {Object} config init parameters\n */\nfunction Gettext ( config ) {\n    var data, meta;\n\n    // sanitize\n    config   = config || {};\n    data     = config.data || {};\n    data[''] = data[''] || {};\n\n    // shortcut\n    meta = config.meta;\n\n    /**\n     * Display the native language translation of a textual message.\n     *\n     * @param {string} msgId textual message\n     *\n     * @return {string} translated text\n     */\n    this.gettext = function ( msgId ) {\n        return data[''][msgId] || msgId;\n    };\n\n\n    /**\n     * The \"p\" in \"pgettext\" stands for \"particular\": fetches a particular translation of the textual message.\n     *\n     * @param {string} context message context\n     * @param {string} msgId textual message\n     *\n     * @return {string} translated text\n     */\n    this.pgettext = function ( context, msgId ) {\n        return data[context] && data[context][msgId] || msgId;\n    };\n\n\n    /**\n     * Display the native language translation of a textual message whose grammatical form depends on a number.\n     *\n     * @param {string} msgId textual message in a singular form\n     * @param {string} plural textual message in a plural form\n     * @param {number} value message number\n     *\n     * @return {string} translated text\n     */\n    this.ngettext = function ( msgId, plural, value ) {\n        /* eslint no-unused-vars: 0 */\n        /* eslint no-eval: 0 */\n        /* eslint id-length: 0 */\n        var n, evalResult;\n\n        if ( DEVELOP ) {\n            if ( Number(value) !== value ) {\n                throw new Error(__filename + ': value must be a number');\n            }\n        }\n\n        if ( data && meta && data[''][msgId] ) {\n            evalResult = eval('n = ' + value + '; ' + meta.plural);\n\n            if ( typeof evalResult === 'boolean' ) {\n                evalResult = +evalResult;\n            }\n\n            // translation\n            return data[''][msgId][evalResult];\n        }\n\n        // english\n        return value === 1 ? msgId : plural;\n    };\n}\n\n\n// correct constructor name\nGettext.prototype.constructor = Gettext;\n\n\n// public\nmodule.exports = Gettext;\n"],"sourceRoot":""}
{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/js/main.js","webpack:///./node_modules/mag-gettext/index.js","webpack:///./node_modules/cjs-emitter/index.js","webpack:///./node_modules/cjs-gettext/index.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","_","gettextWrapper","native","window","stbUPnP","isUPnPInit","UPnP","this","TYPE_FOLDER","TYPE_AUDIO","TYPE_VIDEO","TYPE_IMAGE","TYPE_UNKNOWN","init","getState","core","environment","upnp_conf","prepareUPnPContent","data","result","item","shift","ContentType","type","url","ID","Resources","length","path","Value","size","Size","readOnly","Title","push","openRoot","level","callback","servers","content","Error","getServerListSync","Array","isArray","forEach","server","FriendlyName","UDN","setTimeout","message","openServer","udn","onOpenServer","error","openContext","id","onOpenContext","setFilterName","onOpenPage","openPage","setFilterNameSync","setFilterType","setPageSize","pageSize","onAppInit","config","app","onSettingsInit","load","language","gettext","api","options","description","icon","render","renders","popupSelect","title","saveImmediate","prepareForRender","selected","prepareForSave","gSTB","ServiceControl","getters","saver","savers","parent","constructUPnPSettings","Emitter","Gettext","loader","prepare","pgettext","ngettext","defaultLanguage","xhr","ext","XMLHttpRequest","onload","jsonParseError","json","JSON","parse","responseText","onerror","events","emit","ontimeout","open","send","addListener","once","self","onceWrapper","removeListener","apply","arguments","addListeners","callbacks","filter","fn","undefined","index","event","slice","constructor","meta","msgId","context","plural","evalResult","eval"],"mappings":"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","file":"main.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","/**\n * MAGSDK basic implementation of UPnP plugin.\n *\n * @author Yaroslav Surilov <y.surilov@infomir.com>\n */\n\n'use strict';\n\nvar gettextWrapper = require('mag-gettext'),\n    native         = window.stbUPnP,\n    isUPnPInit     = false,\n    _;\n\n\nif ( !isUPnPInit ) {\n    if ( native ) {\n        native.init();\n    }\n    isUPnPInit = true;\n}\n\n\n/**\n * Construct UPnP worker instance.\n *\n * @constructor\n */\nfunction UPnP () {\n    if ( native ) {\n        /**\n         * Constant types for file type parsing.\n         */\n        this.TYPE_FOLDER  = native.TYPE_FOLDER;\n        this.TYPE_AUDIO   = native.TYPE_AUDIO;\n        this.TYPE_VIDEO   = native.TYPE_VIDEO;\n        this.TYPE_IMAGE   = native.TYPE_IMAGE;\n        this.TYPE_UNKNOWN = native.TYPE_UNKNOWN;\n    }\n}\n\n\n/**\n * Get UPnP service state.\n *\n * @return {string} current UPnP state (\"lan\", \"wlan\", \"off\")\n */\nUPnP.prototype.getState = function () {\n    return core.environment.upnp_conf;\n};\n\n\n/**\n * Add additional information to UPnP items depend on their types.\n *\n * @param {Object[]} data - source data\n *\n * @return {Object[]} UPnP items reached with additional information\n */\nUPnP.prototype.prepareUPnPContent = function ( data ) {\n    var result = [],\n        item   = data.shift();\n\n    while ( item ) {\n        switch ( item.ContentType ) {\n            case this.TYPE_FOLDER:\n                item.type = 9;\n                item.url = item.ID;\n                break;\n            case this.TYPE_AUDIO:\n                item.type = 6;\n                break;\n            case this.TYPE_VIDEO:\n                item.type = 5;\n                break;\n            case this.TYPE_IMAGE:\n                item.type = 7;\n                break;\n            default:\n                item.type = 8;\n                break;\n        }\n\n        if ( item.type !== this.TYPE_FOLDER && item.Resources && item.Resources.length ) {\n            item.path = item.Resources[0].Value;\n            item.size = item.Resources[0].Size;\n        }\n\n        item.Resources = null;\n        item.readOnly = true;\n        item.name = item.Title;\n        result.push(item);\n        item = data.shift();\n    }\n\n    return result;\n};\n\n\n/**\n * Enter the root UPnP item or open it\n *\n * @param {Object} [data] - media item inner data\n * @param {number} level - hierarchy change flag: 0 - no change, 1 - go level deeper, -1 - go level up\n * @param {Function} callback - method to invoke with a result of operation\n */\nUPnP.prototype.openRoot = function ( data, level, callback ) {\n    var servers, content;\n\n    if ( typeof callback !== 'function' ) {\n        throw new Error('[UPnP::openRoot()] callback must be a function');\n    }\n\n    servers = native.getServerListSync();\n    content = [];\n\n    // some data received\n    if ( servers && Array.isArray(servers) && servers.length > 0 ) {\n        servers.forEach(function (server) {\n            content.push({name: server.FriendlyName, url: server.UDN, type: 22});\n        });\n        // go deeper\n        //inServer = false;\n        //levelChange = level;\n        //listLink.total = content.length;\n        setTimeout(function () {\n            callback( null, content );\n        }, 0);\n    } else {\n        setTimeout(function () {\n            callback( {message: 'Unable to get UPnP group servers'} );\n        }, 0);\n    }\n};\n\n\n/**\n * Open server, setting current server.\n *\n * @param {string} udn - server udn\n * @param {Function} callback - method to invoke with a result of operation\n */\nUPnP.prototype.openServer = function ( udn, callback ) {\n    if ( typeof callback !== 'function' ) {\n        throw new Error('[UPnP::openServer()] callback must be a function');\n    }\n\n    native.onOpenServer = function ( data, error ) {\n        if ( error ) {\n            callback(error);\n        } else {\n            callback(null, data);\n        }\n    };\n\n    native.openServer( udn );\n};\n\n\n/**\n * Start retrieving data from the passed stbUPnP.directory.ID.\n *\n * @param {number} id - folder identifier\n * @param {Function} callback - method to invoke with a result of operation\n */\nUPnP.prototype.openContext = function ( id, callback ) {\n    if ( typeof callback !== 'function' ) {\n        throw new Error('[UPnP::openContext()] callback must be a function');\n    }\n\n    native.onOpenContext = function ( data, error ) {\n        if ( error ) {\n            callback(error);\n        } else {\n            callback(null, data);\n        }\n    };\n\n    native.openContext( id );\n};\n\n\n/**\n * Set not case sensitive filter by item name with callback.\n * Filter item name on the occurrence of the passed string filter.\n *\n * @param {string} name - string to filter\n * @param {Function} callback - method to invoke with a result of operation\n */\nUPnP.prototype.setFilterName = function ( name, callback )  {\n    if ( typeof callback !== 'function' ) {\n        throw new Error('[UPnP::setFilterName()] callback must be a function');\n    }\n\n    if ( typeof name === 'string' ) {\n        native.setFilterName(name);\n        native.onOpenPage = function ( data, error ) {\n            if ( error ) {\n                callback(error);\n            } else {\n                callback(null, data);\n            }\n        };\n        native.openPage(0);\n    } else {\n        callback({message: 'Argument is not a string'});\n    }\n};\n\n\n/**\n * Set not case sensitive filter by item name.\n * Filter item name on the occurrence of the passed string filter.\n *\n * @param {string} name - string to filter\n */\nUPnP.prototype.setFilterNameSync = function ( name ) {\n    native.setFilterName(name);\n};\n\n\n/**\n * Set filter by item type.\n *\n * @param {number} type - one of the MEDIA_TYPE_* filter type\n *\n * @return {boolean} operation status\n */\nUPnP.prototype.setFilterType = function ( type ) {\n    return native.setFilterType(type);\n};\n\n\n/**\n * Items per page. Set this attribute, and next 'openContext' call will return setted value.\n *\n * @param {number} size - per page items count\n */\nUPnP.prototype.setPageSize = function ( size ) {\n    if ( typeof size !== 'number' ) {\n        throw new Error('[UPnP::setPageSize()] incorrect size to set, size must be a number');\n    }\n\n    native.pageSize = size;\n};\n\n\n/**\n * Construct UPnP setting option.\n *\n * @param {Object} config - API object\n *\n * @return {Object} structured data for passing into Settings\n */\nfunction constructUPnPSettings ( config ) {\n    var api = config.api;\n\n    return {\n        options: [\n            {\n                id: 'upnp',\n                name: _('Enable UPnP client'),\n                description: '',\n                icon: 'theme-icon theme-icon-upnp',\n                render: api.renders.popupSelect,\n                title: _('Select UPnP client'),\n                saveImmediate: true,\n                environment: {\n                    upnp_conf: '' // eslint-disable-line\n                },\n                prepareForRender: function ( environment, callback ) {\n                    var opt = [\n                        {value: 'off', name: _('Disabled'), selected: environment['upnp_conf'] === 'off'},\n                        {value: 'lan', name: 'LAN', selected: environment['upnp_conf'] === 'lan'},\n                        {value: 'wlan', name: _('Wireless'), selected: environment['upnp_conf'] === 'wlan'}\n                    ];\n\n                    callback(opt);\n                },\n                prepareForSave: function ( value, callback ) {\n                    this.environment['upnp_conf'] = value;\n                    callback();\n                    gSTB.ServiceControl('upnp-service', 'restart');\n                },\n                getter: api.getters.environment,\n                saver: api.savers.environment,\n                type: 'option',\n                parent: 'network'\n            }\n        ]\n    };\n}\n\nmodule.exports = {\n    onAppInit: function ( config, callback ) {\n        // dome some asynchronous operations\n        callback(null, new UPnP(config.app));\n    },\n    onSettingsInit: function ( config, callback ) {\n        gettextWrapper.load({\n            name: core.environment.language,\n            path: config.path + 'lang'\n        }, function () {\n            _ = gettextWrapper.gettext;\n\n            callback(null, constructUPnPSettings(config));\n        });\n    }\n};\n","/**\n * @license The MIT License (MIT)\n * @copyright Stanislav Kalashnik <darkpark.main@gmail.com>\n */\n\n/* eslint no-path-concat: 0 */\n\n'use strict';\n\nvar Emitter = require('cjs-emitter'),\n    Gettext = require('cjs-gettext'),\n    loader  = new Emitter();\n\n\nif ( DEVELOP ) {\n    loader._ = loader.gettext = loader.pgettext = loader.ngettext = function () {\n        throw new Error(__filename + ': you cannot use this function before mag-gettext not yet loaded');\n    };\n}\n\n/**\n * Wrap the given data with gettext instance\n * and export methods to the global scope.\n *\n * @param {Object} [data] localization data\n */\nfunction prepare ( data ) {\n    var gettext = new Gettext(data);\n\n    loader._ = loader.gettext = gettext.gettext;\n    loader.pgettext = gettext.pgettext;\n    loader.ngettext = gettext.ngettext;\n}\n\n\n/**\n * Main application language\n */\nloader.defaultLanguage = 'en';\n\n\n/**\n * Simple gettext implementation.\n *\n * @param {Object} config options\n * @param {string} [config.path=lang] relative path to project root\n * @param {string} config.name language name\n * @param {string} [config.ext=json] language file extension\n * @param {function} callback hook on ready\n */\nloader.load = function ( config, callback ) {\n    var xhr;\n\n    if ( DEVELOP ) {\n        if ( !config.name || typeof config.name !== 'string' ) {\n            throw new Error(__filename + ': config.name must be a nonempty string');\n        }\n        if ( callback && typeof callback !== 'function' ) {\n            throw new Error(__filename + ': wrong callback type');\n        }\n    }\n\n    // defaults\n\n    callback = callback || null;\n    config.ext  = config.ext  || 'json';\n    config.path = config.path || 'lang';\n\n    // is it necessary to request a localization file?\n    if ( config.name === loader.defaultLanguage ) {\n        // no\n        prepare();\n        if ( callback !== null ) {\n            callback(null);\n        }\n    } else {\n        xhr = new XMLHttpRequest();\n\n        xhr.onload = function () {\n            var jsonParseError, json;\n\n            try {\n                json = JSON.parse(xhr.responseText);\n            } catch ( error ) {\n                jsonParseError = error;\n            }\n\n            if ( jsonParseError ) {\n                xhr.onerror(jsonParseError);\n            } else {\n                prepare(json);\n                if ( callback !== null ) {\n                    callback(null);\n                }\n\n                // there are some listeners\n                if ( loader.events['load'] ) {\n                    // notify listeners\n                    loader.emit('load');\n                }\n            }\n        };\n\n        xhr.ontimeout = xhr.onerror = function ( error ) {\n            prepare();\n\n            if ( callback !== null ) {\n                callback(null);\n            }\n\n            // there are some listeners\n            if ( loader.events['error'] ) {\n                // notify listeners\n                loader.emit('error', error);\n            }\n        };\n\n        xhr.open('GET', config.path + '/' + config.name + '.' + config.ext, true);\n        xhr.send(null);\n    }\n};\n\n\n// public\nmodule.exports = loader;\n","/**\n * @license The MIT License (MIT)\n * @author Stanislav Kalashnik <darkpark.main@gmail.com>\n */\n\n/* eslint no-path-concat: 0 */\n\n'use strict';\n\n\n/**\n * Base Events Emitter implementation.\n *\n * @see http://nodejs.org/api/events.html\n * @constructor\n *\n * @example\n * var emitter = new Emitter();\n */\nfunction Emitter () {\n    console.assert(typeof this === 'object', 'must be constructed via new');\n\n    // if ( DEVELOP ) {\n    //     if ( typeof this !== 'object' ) { throw new Error(__filename + ': must be constructed via new'); }\n    // }\n\n    /**\n     * Inner hash table for event names and linked callbacks.\n     * Manual editing should be avoided.\n     *\n     * @member {Object.<string, function[]>}\n     *\n     * @example\n     * {\n     *     click: [\n     *         function click1 () { ... },\n     *         function click2 () { ... }\n     *     ],\n     *     keydown: [\n     *         function () { ... }\n     *     ]\n     * }\n     **/\n    this.events = {};\n}\n\n\nEmitter.prototype = {\n    /**\n     * Bind an event to the given callback function.\n     * The same callback function can be added multiple times for the same event name.\n     *\n     * @param {string} name event identifier\n     * @param {function} callback function to call on this event\n     *\n     * @example\n     * emitter.addListener('click', function ( data ) { ... });\n     * // one more click handler\n     * emitter.addListener('click', function ( data ) { ... });\n     */\n    addListener: function ( name, callback ) {\n        console.assert(arguments.length === 2, 'wrong arguments number');\n        console.assert(typeof name === 'string', 'wrong name type');\n        console.assert(name.length > 0, 'empty name');\n        console.assert(typeof callback === 'function', 'callback should be a function');\n\n        // if ( DEVELOP ) {\n        //     if ( arguments.length !== 2 ) { throw new Error(__filename + ': wrong arguments number'); }\n        //     if ( typeof name !== 'string' || name.length === 0 ) { throw new Error(__filename + ': wrong or empty name'); }\n        //     if ( typeof callback !== 'function' ) { throw new Error(__filename + ': wrong callback type'); }\n        // }\n\n        // initialization may be required\n        this.events[name] = this.events[name] || [];\n        // append this new event to the list\n        this.events[name].push(callback);\n    },\n\n\n    /**\n     * Add a one time listener for the event.\n     * This listener is invoked only the next time the event is fired, after which it is removed.\n     *\n     * @param {string} name event identifier\n     * @param {function} callback function to call on this event\n     *\n     * @example\n     * emitter.once('click', function ( data ) { ... });\n     */\n    once: function ( name, callback ) {\n        // current execution context\n        var self = this;\n\n        if ( DEVELOP ) {\n            if ( arguments.length !== 2 ) {\n                throw new Error(__filename + ': wrong arguments number');\n            }\n            if ( typeof name !== 'string' || name.length === 0 ) {\n                throw new Error(__filename + ': wrong or empty name');\n            }\n            if ( typeof callback !== 'function' ) {\n                throw new Error(__filename + ': wrong callback type');\n            }\n        }\n\n        // initialization may be required\n        this.events[name] = this.events[name] || [];\n        // append this new event to the list\n        this.events[name].push(function onceWrapper () {\n            self.removeListener(name, onceWrapper);\n            callback.apply(self, arguments);\n        });\n    },\n\n\n    /**\n     * Apply multiple listeners at once.\n     *\n     * @param {Object} callbacks event names with callbacks\n     *\n     * @example\n     * emitter.addListeners({\n     *     click: function ( data ) {},\n     *     close: function ( data ) {}\n     * });\n     */\n    addListeners: function ( callbacks ) {\n        var name;\n\n        if ( DEVELOP ) {\n            if ( arguments.length !== 1 ) {\n                throw new Error(__filename + ': wrong arguments number');\n            }\n            if ( typeof callbacks !== 'object' ) {\n                throw new Error(__filename + ': wrong callbacks type');\n            }\n            if ( Object.keys(callbacks).length === 0 ) {\n                throw new Error(__filename + ': no callbacks given');\n            }\n        }\n\n        for ( name in callbacks ) {\n            if ( callbacks.hasOwnProperty(name) ) {\n                this.addListener(name, callbacks[name]);\n            }\n        }\n    },\n\n\n    /**\n     * Remove all instances of the given callback.\n     *\n     * @param {string} name event identifier\n     * @param {function} callback function to remove\n     *\n     * @example\n     * emitter.removeListener('click', func1);\n     */\n    removeListener: function ( name, callback ) {\n        if ( DEVELOP ) {\n            if ( arguments.length !== 2 ) {\n                throw new Error(__filename + ': wrong arguments number');\n            }\n            if ( typeof name !== 'string' || name.length === 0 ) {\n                throw new Error(__filename + ': wrong or empty name');\n            }\n            if ( typeof callback !== 'function' ) {\n                throw new Error(__filename + ': wrong callback type');\n            }\n            if ( this.events[name] && !Array.isArray(this.events[name]) ) {\n                throw new Error(__filename + ': corrupted inner data');\n            }\n        }\n\n        // the event exists and should have some callbacks\n        if ( this.events[name] ) {\n            // rework the callback list to exclude the given one\n            this.events[name] = this.events[name].filter(function callbacksFilter ( fn ) { return fn !== callback; });\n            // event has no more callbacks so clean it\n            if ( this.events[name].length === 0 ) {\n                // as if there were no listeners at all\n                this.events[name] = undefined;\n            }\n        }\n    },\n\n\n    /**\n     * Remove all callbacks for the given event name.\n     * Without event name clears all events.\n     *\n     * @param {string} [name] event identifier\n     *\n     * @example\n     * emitter.removeAllListeners('click');\n     * emitter.removeAllListeners();\n     *\n     * @deprecated\n     */\n    /*removeAllListeners: function ( name ) {\n        if ( DEVELOP ) {\n            if ( arguments.length !== 0 && (typeof name !== 'string' || name.length === 0) ) {\n                throw new Error(__filename + ': wrong or empty name');\n            }\n        }\n\n        // check input\n        if ( arguments.length === 0 ) {\n            // no arguments so remove everything\n            this.events = {};\n        } else if ( name ) {\n            if ( DEVELOP ) {\n                if ( this.events[name] ) { throw new Error(__filename + ': event is not removed'); }\n            }\n\n            // only name is given so remove all callbacks for the given event\n            // but object structure modification should be avoided\n            this.events[name] = undefined;\n        }\n    },*/\n\n\n    /**\n     * Execute each of the listeners in the given order with the supplied arguments.\n     *\n     * @param {string} name event identifier\n     *\n     * @example\n     * emitter.emit('init');\n     * emitter.emit('click', {src: panel1, dst: panel2});\n     * emitter.emit('load', error, data);\n     *\n     * // it's a good idea to emit event only when there are some listeners\n     * if ( this.events['click'] ) {\n     *     this.emit('click', {event: event});\n     * }\n     */\n    emit: function ( name ) {\n        var event = this.events[name],\n            index;\n\n        if ( DEVELOP ) {\n            if ( arguments.length < 1 ) {\n                throw new Error(__filename + ': wrong arguments number');\n            }\n            if ( typeof name !== 'string' || name.length === 0 ) {\n                throw new Error(__filename + ': wrong or empty name');\n            }\n        }\n\n        // the event exists and should have some callbacks\n        if ( event ) {\n            if ( DEVELOP ) {\n                if ( !Array.isArray(event) ) {\n                    throw new Error(__filename + ': wrong event type');\n                }\n            }\n\n            for ( index = 0; index < event.length; index++ ) {\n                if ( DEVELOP ) {\n                    if ( typeof event[index] !== 'function' ) {\n                        throw new Error(__filename + ': wrong event callback type');\n                    }\n                }\n\n                // invoke the callback with parameters\n                event[index].apply(this, Array.prototype.slice.call(arguments, 1));\n            }\n        }\n    }\n};\n\n\n// correct constructor name\nEmitter.prototype.constructor = Emitter;\n\n\n// public\nmodule.exports = Emitter;\n","/**\n * @license The MIT License (MIT)\n * @author Stanislav Kalashnik <darkpark.main@gmail.com>\n */\n\n/* eslint no-path-concat: 0 */\n\n'use strict';\n\n\n/**\n * Translations handler.\n *\n * @constructor\n *\n * @param {Object} config init parameters\n */\nfunction Gettext ( config ) {\n    var data, meta;\n\n    // sanitize\n    config   = config || {};\n    data     = config.data || {};\n    data[''] = data[''] || {};\n\n    // shortcut\n    meta = config.meta;\n\n    /**\n     * Display the native language translation of a textual message.\n     *\n     * @param {string} msgId textual message\n     *\n     * @return {string} translated text\n     */\n    this.gettext = function ( msgId ) {\n        return data[''][msgId] || msgId;\n    };\n\n\n    /**\n     * The \"p\" in \"pgettext\" stands for \"particular\": fetches a particular translation of the textual message.\n     *\n     * @param {string} context message context\n     * @param {string} msgId textual message\n     *\n     * @return {string} translated text\n     */\n    this.pgettext = function ( context, msgId ) {\n        return data[context] && data[context][msgId] || msgId;\n    };\n\n\n    /**\n     * Display the native language translation of a textual message whose grammatical form depends on a number.\n     *\n     * @param {string} msgId textual message in a singular form\n     * @param {string} plural textual message in a plural form\n     * @param {number} value message number\n     *\n     * @return {string} translated text\n     */\n    this.ngettext = function ( msgId, plural, value ) {\n        /* eslint no-unused-vars: 0 */\n        /* eslint no-eval: 0 */\n        /* eslint id-length: 0 */\n        var n, evalResult;\n\n        if ( DEVELOP ) {\n            if ( Number(value) !== value ) {\n                throw new Error(__filename + ': value must be a number');\n            }\n        }\n\n        if ( data && meta && data[''][msgId] ) {\n            evalResult = eval('n = ' + value + '; ' + meta.plural);\n\n            if ( typeof evalResult === 'boolean' ) {\n                evalResult = +evalResult;\n            }\n\n            // translation\n            return data[''][msgId][evalResult];\n        }\n\n        // english\n        return value === 1 ? msgId : plural;\n    };\n}\n\n\n// correct constructor name\nGettext.prototype.constructor = Gettext;\n\n\n// public\nmodule.exports = Gettext;\n"],"sourceRoot":""}
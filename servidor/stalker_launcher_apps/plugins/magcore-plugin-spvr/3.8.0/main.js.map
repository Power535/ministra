{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/cjs-emitter/index.js","webpack:///./src/js/main.js","webpack:///./node_modules/mag-gettext/index.js","webpack:///./node_modules/cjs-gettext/index.js","webpack:///./node_modules/magcore-plugin-content-board/index.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","Emitter","this","events","addListener","callback","push","once","self","onceWrapper","removeListener","apply","arguments","addListeners","callbacks","filter","fn","length","undefined","emit","index","event","Array","slice","constructor","gettext","gettextWrapper","apiConst","providerDaemon","stateToText","provider","daemon","Client","myself","updateTime","records","hash","timerId","enabled","MODE_STALKER","defineProperties","list","set","updateInterval","newTime","clearInterval","setInterval","update","addItem","item","some","oldItem","id","api","removeItem","ind","splice","errorCodes","-1","-2","-3","-4","states","WAITING","RECORDING","ERROR","FINISHED","errors","WRONG_ID","SERVER_ERROR","WRONG_RECORD_OBJECT","API_NOT_AVAILABLE","status","0","1","2","add","data","body","ch_id","startTime","start_time","endTime","end_time","core","backend","request","version","method","JSON","stringify","onload","error","response","serverData","parse","message","errorText","code","state","url","path","channel","ch_name","channelId","progress","server","downloadable","stop","stopCallback","onloadResponse","time","Date","getTime","onerror","remove","parseError","indexOf","getFileUrl","mediaId","media_id","reset","destroy","rawData","Math","ceil","emitProgress","emitChange","isActive","idToIndexHash","client","wrapped","layout","layouts","record","geometry","horizontal","getUrl","mime","deleted","init","map","getUrlCallback","search","text","onInit","config","load","environment","language","onAppInit","onContentBoardInit","Gettext","loader","prepare","_","pgettext","ngettext","defaultLanguage","xhr","ext","XMLHttpRequest","jsonParseError","json","responseText","ontimeout","open","send","meta","msgId","context","plural","evalResult","eval","tvChannel","video","static","application","square","vertical","round","actions","favorite","accessControl","expandItemContent"],"mappings":"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","file":"main.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","/**\n * @license The MIT License (MIT)\n * @author Stanislav Kalashnik <darkpark.main@gmail.com>\n */\n\n/* eslint no-path-concat: 0 */\n\n'use strict';\n\n\n/**\n * Base Events Emitter implementation.\n *\n * @see http://nodejs.org/api/events.html\n * @constructor\n *\n * @example\n * var emitter = new Emitter();\n */\nfunction Emitter () {\n    console.assert(typeof this === 'object', 'must be constructed via new');\n\n    // if ( DEVELOP ) {\n    //     if ( typeof this !== 'object' ) { throw new Error(__filename + ': must be constructed via new'); }\n    // }\n\n    /**\n     * Inner hash table for event names and linked callbacks.\n     * Manual editing should be avoided.\n     *\n     * @member {Object.<string, function[]>}\n     *\n     * @example\n     * {\n     *     click: [\n     *         function click1 () { ... },\n     *         function click2 () { ... }\n     *     ],\n     *     keydown: [\n     *         function () { ... }\n     *     ]\n     * }\n     **/\n    this.events = {};\n}\n\n\nEmitter.prototype = {\n    /**\n     * Bind an event to the given callback function.\n     * The same callback function can be added multiple times for the same event name.\n     *\n     * @param {string} name event identifier\n     * @param {function} callback function to call on this event\n     *\n     * @example\n     * emitter.addListener('click', function ( data ) { ... });\n     * // one more click handler\n     * emitter.addListener('click', function ( data ) { ... });\n     */\n    addListener: function ( name, callback ) {\n        console.assert(arguments.length === 2, 'wrong arguments number');\n        console.assert(typeof name === 'string', 'wrong name type');\n        console.assert(name.length > 0, 'empty name');\n        console.assert(typeof callback === 'function', 'callback should be a function');\n\n        // if ( DEVELOP ) {\n        //     if ( arguments.length !== 2 ) { throw new Error(__filename + ': wrong arguments number'); }\n        //     if ( typeof name !== 'string' || name.length === 0 ) { throw new Error(__filename + ': wrong or empty name'); }\n        //     if ( typeof callback !== 'function' ) { throw new Error(__filename + ': wrong callback type'); }\n        // }\n\n        // initialization may be required\n        this.events[name] = this.events[name] || [];\n        // append this new event to the list\n        this.events[name].push(callback);\n    },\n\n\n    /**\n     * Add a one time listener for the event.\n     * This listener is invoked only the next time the event is fired, after which it is removed.\n     *\n     * @param {string} name event identifier\n     * @param {function} callback function to call on this event\n     *\n     * @example\n     * emitter.once('click', function ( data ) { ... });\n     */\n    once: function ( name, callback ) {\n        // current execution context\n        var self = this;\n\n        if ( DEVELOP ) {\n            if ( arguments.length !== 2 ) {\n                throw new Error(__filename + ': wrong arguments number');\n            }\n            if ( typeof name !== 'string' || name.length === 0 ) {\n                throw new Error(__filename + ': wrong or empty name');\n            }\n            if ( typeof callback !== 'function' ) {\n                throw new Error(__filename + ': wrong callback type');\n            }\n        }\n\n        // initialization may be required\n        this.events[name] = this.events[name] || [];\n        // append this new event to the list\n        this.events[name].push(function onceWrapper () {\n            self.removeListener(name, onceWrapper);\n            callback.apply(self, arguments);\n        });\n    },\n\n\n    /**\n     * Apply multiple listeners at once.\n     *\n     * @param {Object} callbacks event names with callbacks\n     *\n     * @example\n     * emitter.addListeners({\n     *     click: function ( data ) {},\n     *     close: function ( data ) {}\n     * });\n     */\n    addListeners: function ( callbacks ) {\n        var name;\n\n        if ( DEVELOP ) {\n            if ( arguments.length !== 1 ) {\n                throw new Error(__filename + ': wrong arguments number');\n            }\n            if ( typeof callbacks !== 'object' ) {\n                throw new Error(__filename + ': wrong callbacks type');\n            }\n            if ( Object.keys(callbacks).length === 0 ) {\n                throw new Error(__filename + ': no callbacks given');\n            }\n        }\n\n        for ( name in callbacks ) {\n            if ( callbacks.hasOwnProperty(name) ) {\n                this.addListener(name, callbacks[name]);\n            }\n        }\n    },\n\n\n    /**\n     * Remove all instances of the given callback.\n     *\n     * @param {string} name event identifier\n     * @param {function} callback function to remove\n     *\n     * @example\n     * emitter.removeListener('click', func1);\n     */\n    removeListener: function ( name, callback ) {\n        if ( DEVELOP ) {\n            if ( arguments.length !== 2 ) {\n                throw new Error(__filename + ': wrong arguments number');\n            }\n            if ( typeof name !== 'string' || name.length === 0 ) {\n                throw new Error(__filename + ': wrong or empty name');\n            }\n            if ( typeof callback !== 'function' ) {\n                throw new Error(__filename + ': wrong callback type');\n            }\n            if ( this.events[name] && !Array.isArray(this.events[name]) ) {\n                throw new Error(__filename + ': corrupted inner data');\n            }\n        }\n\n        // the event exists and should have some callbacks\n        if ( this.events[name] ) {\n            // rework the callback list to exclude the given one\n            this.events[name] = this.events[name].filter(function callbacksFilter ( fn ) { return fn !== callback; });\n            // event has no more callbacks so clean it\n            if ( this.events[name].length === 0 ) {\n                // as if there were no listeners at all\n                this.events[name] = undefined;\n            }\n        }\n    },\n\n\n    /**\n     * Remove all callbacks for the given event name.\n     * Without event name clears all events.\n     *\n     * @param {string} [name] event identifier\n     *\n     * @example\n     * emitter.removeAllListeners('click');\n     * emitter.removeAllListeners();\n     *\n     * @deprecated\n     */\n    /*removeAllListeners: function ( name ) {\n        if ( DEVELOP ) {\n            if ( arguments.length !== 0 && (typeof name !== 'string' || name.length === 0) ) {\n                throw new Error(__filename + ': wrong or empty name');\n            }\n        }\n\n        // check input\n        if ( arguments.length === 0 ) {\n            // no arguments so remove everything\n            this.events = {};\n        } else if ( name ) {\n            if ( DEVELOP ) {\n                if ( this.events[name] ) { throw new Error(__filename + ': event is not removed'); }\n            }\n\n            // only name is given so remove all callbacks for the given event\n            // but object structure modification should be avoided\n            this.events[name] = undefined;\n        }\n    },*/\n\n\n    /**\n     * Execute each of the listeners in the given order with the supplied arguments.\n     *\n     * @param {string} name event identifier\n     *\n     * @example\n     * emitter.emit('init');\n     * emitter.emit('click', {src: panel1, dst: panel2});\n     * emitter.emit('load', error, data);\n     *\n     * // it's a good idea to emit event only when there are some listeners\n     * if ( this.events['click'] ) {\n     *     this.emit('click', {event: event});\n     * }\n     */\n    emit: function ( name ) {\n        var event = this.events[name],\n            index;\n\n        if ( DEVELOP ) {\n            if ( arguments.length < 1 ) {\n                throw new Error(__filename + ': wrong arguments number');\n            }\n            if ( typeof name !== 'string' || name.length === 0 ) {\n                throw new Error(__filename + ': wrong or empty name');\n            }\n        }\n\n        // the event exists and should have some callbacks\n        if ( event ) {\n            if ( DEVELOP ) {\n                if ( !Array.isArray(event) ) {\n                    throw new Error(__filename + ': wrong event type');\n                }\n            }\n\n            for ( index = 0; index < event.length; index++ ) {\n                if ( DEVELOP ) {\n                    if ( typeof event[index] !== 'function' ) {\n                        throw new Error(__filename + ': wrong event callback type');\n                    }\n                }\n\n                // invoke the callback with parameters\n                event[index].apply(this, Array.prototype.slice.call(arguments, 1));\n            }\n        }\n    }\n};\n\n\n// correct constructor name\nEmitter.prototype.constructor = Emitter;\n\n\n// public\nmodule.exports = Emitter;\n","/**\n * MAGSDK basic implementation of spvr plugin.\n *\n * @author Fedotov D. <bas.jsdev@gmail.com>\n */\n\n'use strict';\n\n\nvar Emitter        = require('cjs-emitter'),\n    gettextWrapper = require('mag-gettext'),\n    apiConst       = require('magcore-plugin-content-board'),\n    providerDaemon = {},\n    stateToText    = ['', 'Scheduled recording', 'Recording', 'Recording error!', 'Recorded'],\n    provider       = new Emitter(),\n    daemon         = new Emitter(),\n    gettext;\n\n\ndaemon.list = [];\n\ndaemon.addItem = function ( item ) {\n    var weHaveIt = daemon.list.some(function ( oldItem ) {\n        return oldItem.id === item.id;\n    });\n\n    if ( !weHaveIt && provider.api ) {\n        daemon.list.push(item);\n        // add new item in provider list\n        providerDaemon.addItem(item);\n    }\n};\n\ndaemon.removeItem = function ( item ) {\n    var weHadIt = daemon.list.some(function ( oldItem, ind ) {\n        if ( oldItem.id === item.id ) {\n            daemon.list.splice(ind, 1);\n            return true;   // eslint-disable-line\n        } else {           // eslint-disable-line\n            return false;  // eslint-disable-line\n        }\n    });\n\n    if ( weHadIt && provider.api ) {\n        // tell provider to remove item\n        providerDaemon.removeItem(item);\n    }\n};\n\n\nfunction Client () {\n    var self = this;\n\n    Emitter.call(this);\n\n    this.updateTime = 6500;\n    this.records = [];\n    this.hash = {};\n    this.timerId = null;\n    this.enabled = !!MODE_STALKER;\n\n    // set hidden fields\n    Object.defineProperties(this, {\n        list: {\n            get: function () {\n                return self.records;\n            },\n            set: function () { return false; }\n        },\n        updateInterval: {\n            get: function () {\n                return self.updateTime;\n            },\n            set: function ( newTime ) {\n                self.updateTime = newTime;\n                clearInterval(self.timerId);\n                if ( !self.enabled ) { return; }\n                self.timerId = setInterval(self.update, self.updateTime);\n            }\n        }\n    });\n\n    // first launch\n    this.update();\n\n    // check info and trigger events if something was changed\n    this.timerId = setInterval(\n        (function ( myself ) {\n            return function () {\n                myself.update();\n            };\n        })(this),\n        self.updateTime\n    );\n}\n\n\nClient.prototype = Object.create(Emitter.prototype);\nClient.prototype.constructor = Client;\n\n\nClient.prototype.errorCodes = {\n    '-1': 'Wrong channel id.',\n    '-2': 'Server error.',\n    '-3': 'Wrong server record object.',\n    '-4': 'Server api not available.'\n};\n\nClient.prototype.states = {\n    WAITING: 1,\n    RECORDING: 2,\n    ERROR: 3,\n    FINISHED: 4\n};\n\nClient.prototype.errors = {\n    // Wrong channel id\n    WRONG_ID: '-1',\n    // Server error\n    SERVER_ERROR: '-2',\n    // Wrong server record object\n    WRONG_RECORD_OBJECT: '-3',\n    // Server api not available\n    API_NOT_AVAILABLE: '-4'\n};\n\n\n// make it's states compatible with local pvr\n// original server codes: 0 - waiting, 1 - recording, 2 - finished\nClient.prototype.status = {0: 1, 1: 2, 2: 4};\n\n\n/**\n * Add new record.\n * @param {Object} data record info\n * @param {string} data.id channel id at server\n * @param {number} data.startTime start time\n * @param {number} data.endTime end time\n * @param {function} callback callback\n *\n * @example\n * spvr.add({\n *     id: 14,\n *     startTime: Math.ceil((new Date()).getTime() / 1000 + 10),\n *     endTime: Math.ceil((new Date()).getTime() / 1000 + 500)\n * }, function ( error, data ) {\n *     console.log(error);\n *     console.log(data);\n * });\n */\nClient.prototype.add = function ( data, callback ) {\n    var self = this,\n        body;\n\n    if ( typeof callback !== 'function' ) {\n        console.log('Wrong callback function.');\n\n        return;\n    }\n    if ( !data.id ) {\n        callback({code: this.errors.WRONG_ID, message: this.errorCodes[this.errors.WRONG_ID]});\n\n        return;\n    }\n    if ( !this.enabled ) {\n        callback({code: this.errors.API_NOT_AVAILABLE, message: this.errorCodes[this.errors.API_NOT_AVAILABLE]});\n\n        return;\n    }\n    /* eslint-disable */\n    body = {ch_id: data.id};\n    if ( data.startTime ) {\n        body.start_time = data.startTime;\n    }\n    if ( data.endTime ) {\n        body.end_time = data.endTime;\n    }\n    /* eslint-enable */\n\n    core.backend.request('recordings', {\n        version: 3,\n        method: 'POST',\n        body: JSON.stringify(body),\n        onload: function ( error, response ) {\n            var serverData, item;\n\n            if ( error ) {\n                try {\n                    response = JSON.parse(response).message;\n                } catch ( errorText ) {\n                    response = errorText;\n                }\n\n                callback({code: self.errors.SERVER_ERROR, message: response});\n            } else {\n                serverData = response.data;\n                item = new Emitter();\n                item.serverData = {\n                    id: serverData.id,\n                    state: self.states.WAITING,\n                    url: '',\n                    path: '',\n                    channel: serverData.ch_name,\n                    channelId: serverData.ch_id,\n                    name: serverData.name || (serverData.ch_name + ' ' + serverData.id),\n                    startTime: serverData.start_time,\n                    endTime: serverData.end_time,\n                    progress: 0,\n                    server: true,\n                    downloadable: serverData.downloadable\n                };\n\n                item.states = self.states;\n\n                item.stop = function ( stopCallback ) {\n                    core.backend.request('recordings/' + this.data.id + '/stop', {\n                        version: 3,\n                        method: 'PUT',\n                        onload: function ( error, onloadResponse ) {\n                            if ( error ) {\n                                stopCallback({\n                                    code: self.errors.SERVER_ERROR,\n                                    message: self.errorCodes[self.errors.SERVER_ERROR]\n                                });\n                            } else if ( onloadResponse && onloadResponse.data && !onloadResponse.error ) {\n                                if ( self.events['stop'] ) {\n                                    self.emit('stop', {item: this, time: (new Date()).getTime()});\n                                }\n                                stopCallback(null, true);\n                            } else {\n                                stopCallback({\n                                    code: self.errors.SERVER_ERROR,\n                                    message: self.errorCodes[self.errors.SERVER_ERROR]\n                                });\n                            }\n                        },\n                        onerror: function () {\n                            console.log('spvr.add onerror');\n                        }\n                    });\n                };\n\n                self.hash[item.data.id] = item;\n                self.records.push(item);\n                daemon.addItem(item.data);\n                if ( self.events['add'] ) {\n                    self.emit('add', {item: item, time: (new Date()).getTime()});\n                }\n                callback(null, true);\n            }\n        },\n        onerror: function () {\n            console.log('spvr.add onerror');\n        }\n    });\n};\n\n\n/**\n * Remove record\n * @param {Emitter} item record instance\n * @param {function} callback callback\n */\nClient.prototype.remove = function ( item, callback ) {\n    var self = this;\n\n    if ( typeof callback !== 'function' ) {\n        console.log('Wrong callback function.');\n\n        return;\n    }\n    if ( !this.enabled ) {\n        callback({code: this.errors.API_NOT_AVAILABLE, message: this.errorCodes[this.errors.API_NOT_AVAILABLE]});\n\n        return;\n    }\n    if ( !item || !(item instanceof Emitter) ) {\n        callback({code: this.errors.WRONG_RECORD_OBJECT, message: this.errorCodes[this.errors.WRONG_RECORD_OBJECT]});\n\n        return;\n    }\n\n    core.backend.request('recordings/' + item.data.id, {\n        version: 3,\n        method: 'DELETE',\n        onload: function ( error, response ) {\n            if ( error ) {\n                try {\n                    response = JSON.parse(response).message;\n                } catch ( parseError ) {\n                    response = parseError;\n                }\n                //console.log(response);\n\n                callback({\n                    code:    self.errors.SERVER_ERROR,\n                    message: self.errorCodes[self.errors.SERVER_ERROR]\n                });\n            } else if ( response && response.data && !response.error ) {\n                delete self.hash[item.data.id];\n                daemon.removeItem((self.records.splice(self.records.indexOf(item), 1))[0].data);\n                if ( self.events['remove'] ) {\n                    self.emit('remove', {item: item, time: (new Date()).getTime()});\n                }\n                callback(null, true);\n            } else {\n                callback({\n                    code:    self.errors.SERVER_ERROR,\n                    message: self.errorCodes[self.errors.SERVER_ERROR]\n                });\n            }\n        },\n        onerror: function () {\n            console.log('spvr->remove->onerror');\n        }\n    });\n};\n\n\n/**\n * Get record file url for downloading\n * @param {Emitter} item record instance\n * @param {function} callback callback\n */\nClient.prototype.getFileUrl = function ( item, callback ) {\n    var self = this;\n\n    if ( typeof callback !== 'function' ) {\n        console.log('Wrong callback function.');\n\n        return;\n    }\n    if ( !this.enabled ) {\n        callback({\n            code:    this.errors.API_NOT_AVAILABLE,\n            message: this.errorCodes[this.errors.API_NOT_AVAILABLE]\n        });\n\n        return;\n    }\n    if ( !item || !(item instanceof Emitter) ) {\n        callback({\n            code:    this.errors.WRONG_RECORD_OBJECT,\n            message: this.errorCodes[this.errors.WRONG_RECORD_OBJECT]\n        });\n\n        return;\n    }\n\n    core.backend.request('recordings/' + item.data.id + '/link', {\n        version: 3,\n        method: 'GET',\n        onload: function ( error, response ) {\n            if ( error ) {\n                try {\n                    response = JSON.parse(response).message;\n                } catch ( parseError ) {\n                    response = parseError;\n                }\n                //console.log(response);\n\n                callback({code: self.errors.SERVER_ERROR, message: self.errorCodes[self.errors.SERVER_ERROR]});\n            } else if ( response.data && response.data.url ) {\n                console.log('spvr->get->url:' + response.data.url);\n                callback(null, {url: response.data.url, mediaId: response.data.media_id});\n            } else {\n                callback({code: self.errors.SERVER_ERROR, message: self.errorCodes[self.errors.SERVER_ERROR]});\n            }\n        },\n        onerror: function () {\n            console.log('spvr.url onerror');\n        }\n    });\n};\n\n\n/**\n * Reset list. All current server records will be marked as new and corresponding events will be emitted.\n */\nClient.prototype.reset = function () {\n    this.records = [];\n    this.hash = {};\n    this.update();\n};\n\n/**\n * Stop plugin and remove all it listeners. Use it for cleanup before app exit.\n */\nClient.prototype.destroy = function () {\n    this.events = {};\n    this.records = [];\n    this.hash = {};\n    clearInterval(this.timerId);\n};\n\n/**\n * Check for changes. If there are some emit corresponding events. To set new time interval use \"updateInterval\" property\n *\n * @param {function} callback use it if you need to know when data will be updated and ready for use\n *\n * @example\n * this.updateInterval = 999;\n */\nClient.prototype.update = function ( callback ) {\n    var self = this;\n\n    if ( !this.enabled ) {\n        clearInterval(this.timerId);\n\n        return;\n    }\n\n    core.backend.request('recordings', {\n        version: 3,\n        method: 'GET',\n        onload: function ( error, response ) {\n            var rawData, ind, item, progress, data;\n\n            if ( error ) {\n                console.log('spvr->update->error');\n                console.log(error);\n                console.log(response);\n            } else {\n                try {\n                    rawData = response.data;\n                } catch ( error ) {\n                    console.log('spvr->update->parsing error ' + error);\n                    rawData = [];\n                }\n\n                for ( ind = 0; ind < rawData.length; ind++ ) {\n                    // if new item, trigger event\n                    if ( self.hash[rawData[ind].id] ) {\n                        //console.log('hash has such id, it state:' + status[rawData[ind].status]);\n                        item = self.hash[rawData[ind].id];\n                        // check if progress changed (every running and finished task -\n                        // because of async API, we need to sync progress and state separately)\n                        if ( self.status[rawData[ind].status] === 2 || self.status[rawData[ind].status] === 4 ) {\n                            progress = Math.ceil(((((new Date()).getTime() / 1000) - rawData[ind].start_time) /\n                                (rawData[ind].end_time - rawData[ind].start_time)) * 100);\n                            progress = progress < 0 ? 0 : progress;\n                            progress = progress > 100 ? 100 : progress;\n                            if ( progress !== item.data.progress ) {\n                                item.data.progress = progress;\n                                self.records[self.records.indexOf(item)].data.progress = progress;\n                                // tell provider to update item progress\n                                providerDaemon.emitProgress(item);\n                                if ( self.events['progress'] ) {\n                                    self.emit('progress', {item: item, time: (new Date()).getTime()});\n                                    console.log('progress->id:' + rawData[ind].id);\n                                }\n                            }\n                        }\n                        // check if state changed\n                        if ( self.status[rawData[ind].status] !== item.data.state ) {\n                            item.data.state = self.status[rawData[ind].status];\n                            item.data.downloadable = rawData[ind].downloadable;\n                            self.records[self.records.indexOf(item)].data.state = self.status[rawData[ind].status];\n                            self.records[self.records.indexOf(item)].data.downloadable = rawData[ind].downloadable;\n                            // tell provider to update item status\n                            providerDaemon.emitChange(item);\n                            if ( self.events['state'] ) {\n                                self.emit('state', {item: item, time: (new Date()).getTime()});\n                                console.log('spvr->status->id:' + rawData[ind].id);\n                            }\n                        }\n                    } else {\n                        data = rawData[ind];\n                        item = new Emitter();\n                        item.data = {\n                            id: data.id,\n                            state: self.status[data.status],\n                            url: '',\n                            path: '',\n                            channel: data.ch_name,\n                            channelId: data.ch_id,\n                            name: data.name || (data.ch_name + ' ' + data.id),\n                            startTime: data.start_time,\n                            endTime: data.end_time,\n                            progress: 0,\n                            server: true,\n                            downloadable: data.downloadable\n                        };\n\n                        progress = Math.ceil(((((new Date()).getTime() / 1000) - data.start_time) / (data.end_time - data.start_time)) * 100);\n                        progress = progress < 0 ? 0 : progress;\n                        progress = progress > 100 ? 100 : progress;\n                        item.data.progress = progress;\n\n                        item.states = {\n                            /** @const {number} */\n                            WAITING: 1,\n                            /** @const {number} */\n                            RECORDING: 2,\n                            /** @const {number} */\n                            FINISHED: 4,\n                            /** @const {number} */\n                            ERROR: 3\n                        };\n\n                        item.stop = function ( stopCallback ) {\n                            core.backend.request('recordings/' + this.data.id + '/stop', {\n                                version: 3,\n                                method: 'PUT',\n                                onload: function ( error, onloadResponse ) {\n                                    if ( error ) {\n                                        stopCallback({\n                                            code: self.errors.SERVER_ERROR,\n                                            message: self.errorCodes[self.errors.SERVER_ERROR]\n                                        });\n                                    } else if ( onloadResponse && onloadResponse.data && !onloadResponse.error ) {\n                                        if ( self.events['stop'] ) {\n                                            self.emit('stop', {item: this, time: (new Date()).getTime()});\n                                        }\n                                        stopCallback(null, true);\n                                    } else {\n                                        stopCallback({\n                                            code: self.errors.SERVER_ERROR,\n                                            message: self.errorCodes[self.errors.SERVER_ERROR]\n                                        });\n                                    }\n                                },\n                                onerror: function () {\n                                    console.log('spvr.add onerror');\n                                }\n                            });\n                        };\n\n                        self.hash[item.data.id] = item;\n                        self.records.push(item);\n                        daemon.addItem(item.data);\n                        if ( self.events['add'] ) {\n                            self.emit('add', {item: item, time: (new Date()).getTime()});\n                        }\n                    }\n                }\n            }\n            if ( typeof callback === 'function' ) {\n                callback();\n            }\n        },\n        onerror: function ( data ) {\n            console.log('spvr->update->onerror');\n            console.log(data);\n            if ( typeof callback === 'function' ) {\n                callback();\n            }\n        }\n    });\n};\n\n\nproviderDaemon = {\n    /**\n     * No need for this daemon so turn it off\n     */\n    isActive: false,\n    /**\n     * Hash to connect raw records data and records objects. Otherwise on each update operation we should\n     * use multiple cycles to build connections between raw data and record objects and only then apply changes.\n     *\n     * @type {Object}\n     */\n    idToIndexHash: {},\n    /**\n     * Array of all records from all apps.\n     */\n    list: [],\n    /**\n     * Provider should imitate application to be able to listen for all records updates.\n     */\n    client: null,\n    /**\n     * Synchronise changes in records on gSTB level and if there are some - trigger corresponding callbacks in clients.\n     *\n     * @param {Object} item record wrapped record\n     */\n    emitChange: function ( item ) {\n        try {\n            providerDaemon.idToIndexHash[item.id].data.state = stateToText[item.state];\n            if ( providerDaemon.idToIndexHash[item.id].events['stop'] ) {\n                providerDaemon.idToIndexHash[item.id].emit('change');\n            }\n        } catch ( error ) {\n            console.log('pvr provider: error in one of \"add\" listeners. ' + error);\n        }\n    },\n    emitProgress: function ( item ) {\n        try {\n            providerDaemon.idToIndexHash[item.id].data.progress = item.progress;\n            if ( providerDaemon.idToIndexHash[item.id].events['change'] ) {\n                providerDaemon.idToIndexHash[item.id].emit('change');\n            }\n        } catch ( error ) {\n            console.log('pvr provider: error in one of \"add\" listeners. ' + error);\n        }\n    },\n    addItem: function ( item ) {\n        var wrapped = new Emitter();\n\n        wrapped.id = item.id;\n        wrapped.layout = apiConst.layouts.record;\n        wrapped.geometry = apiConst.geometry.horizontal;\n        wrapped.data = {\n            name: item.name,\n            progress: item.progress,\n            state: stateToText[item.state],\n            url: function ( callback ) {\n                provider.getUrl(item.id, callback);\n            },\n            mime: 'content/video'\n        };\n\n        providerDaemon.idToIndexHash[item.id] = wrapped;\n        providerDaemon.list.push(wrapped);\n\n        try {\n            if ( provider.events['add'] ) {\n                provider.emit('add', [wrapped]);\n            }\n        } catch ( error ) {\n            console.log('pvr provider: error in one of \"add\" listeners. ' + error);\n        }\n    },\n    removeItem: function ( item ) {\n        var deleted = providerDaemon.list.splice(providerDaemon.list.indexOf(providerDaemon.idToIndexHash[item.id]), 1);\n\n        delete providerDaemon.idToIndexHash[item.id];\n\n        try {\n            if ( provider.events['remove'] ) {\n                provider.emit('remove', deleted);\n            }\n        } catch ( error ) {\n            console.log('pvr provider: error in one of \"remove\" listeners. ' + error);\n        }\n    }\n};\n\nprovider.getUrl = function ( id, callback ) {\n    core.backend.request('recordings/' + id + '/link', {\n        version: 3,\n        method: 'GET',\n        onload: function ( error, response ) {\n            if ( error ) {\n                try {\n                    response = JSON.parse(response).message;\n                } catch ( parseError ) {\n                    response = parseError;\n                }\n                //console.log(response);\n\n                callback({\n                    code: Client.prototype.errors.SERVER_ERROR,\n                    message: Client.prototype.errorCodes[Client.prototype.errors.SERVER_ERROR]\n                });\n            } else if ( response.data && response.data.url ) {\n                console.log('spvr->get->url:' + response.data.url);\n                callback(null, response.data.url);\n            } else {\n                callback({\n                    code: Client.prototype.errors.SERVER_ERROR,\n                    message: Client.prototype.errorCodes[Client.prototype.errors.SERVER_ERROR]\n                });\n            }\n        },\n        onerror: function () {\n            callback({\n                code: Client.prototype.errors.SERVER_ERROR,\n                message: Client.prototype.errorCodes[Client.prototype.errors.SERVER_ERROR]\n            });\n        }\n    });\n};\n\nprovider.init = function ( api, callback ) {\n    this.api = api;\n\n    providerDaemon.client = new Client();\n    providerDaemon.client.enabled = true;\n    providerDaemon.isActive = true;\n\n    providerDaemon.client.update(function () {\n        callback({\n            provider: provider,\n            data: daemon.list.map(function ( item ) {\n                var wrapped = new Emitter();\n\n                wrapped.id = item.id;\n                wrapped.layout = apiConst.layouts.record;\n                wrapped.geometry = apiConst.geometry.horizontal;\n                wrapped.data = {\n                    name: item.name,\n                    progress: item.progress,\n                    state: stateToText[item.state],\n                    url: function ( getUrlCallback ) {\n                        provider.getUrl(item.id, getUrlCallback);\n                    },\n                    mime: 'content/video'\n                };\n\n                providerDaemon.idToIndexHash[item.id] = wrapped;\n                providerDaemon.list.push(wrapped);\n\n                return wrapped;\n            })\n        });\n    });\n};\n\nprovider.search = function ( text, callback ) {\n    callback(false, providerDaemon.list.map(function ( item ) {  // eslint-disable-line\n        if ( item.data.name.indexOf(text) !== -1 ) {\n            return item;\n        }\n    }));\n};\n\n\nmodule.exports = {\n    onInit: function ( config, callback ) {\n        gettextWrapper.load({\n            name: core.environment.language,\n            path: config.path + 'lang'\n        }, function () {\n            gettext = gettextWrapper.gettext;\n            stateToText = ['', gettext('Scheduled recording'), gettext('Recording'), gettext('Recording error!'), gettext('Recorded')];\n            callback();\n        });\n    },\n    onAppInit: function ( config, callback ) {\n        callback(null, new Client());\n    },\n    onContentBoardInit: function ( config, callback ) {\n        provider.init(config.api, function ( data ) {\n            callback(null, data);\n        });\n    }\n};\n","/**\n * @license The MIT License (MIT)\n * @copyright Stanislav Kalashnik <darkpark.main@gmail.com>\n */\n\n/* eslint no-path-concat: 0 */\n\n'use strict';\n\nvar Emitter = require('cjs-emitter'),\n    Gettext = require('cjs-gettext'),\n    loader  = new Emitter();\n\n\nif ( DEVELOP ) {\n    loader._ = loader.gettext = loader.pgettext = loader.ngettext = function () {\n        throw new Error(__filename + ': you cannot use this function before mag-gettext not yet loaded');\n    };\n}\n\n/**\n * Wrap the given data with gettext instance\n * and export methods to the global scope.\n *\n * @param {Object} [data] localization data\n */\nfunction prepare ( data ) {\n    var gettext = new Gettext(data);\n\n    loader._ = loader.gettext = gettext.gettext;\n    loader.pgettext = gettext.pgettext;\n    loader.ngettext = gettext.ngettext;\n}\n\n\n/**\n * Main application language\n */\nloader.defaultLanguage = 'en';\n\n\n/**\n * Simple gettext implementation.\n *\n * @param {Object} config options\n * @param {string} [config.path=lang] relative path to project root\n * @param {string} config.name language name\n * @param {string} [config.ext=json] language file extension\n * @param {function} callback hook on ready\n */\nloader.load = function ( config, callback ) {\n    var xhr;\n\n    if ( DEVELOP ) {\n        if ( !config.name || typeof config.name !== 'string' ) {\n            throw new Error(__filename + ': config.name must be a nonempty string');\n        }\n        if ( callback && typeof callback !== 'function' ) {\n            throw new Error(__filename + ': wrong callback type');\n        }\n    }\n\n    // defaults\n\n    callback = callback || null;\n    config.ext  = config.ext  || 'json';\n    config.path = config.path || 'lang';\n\n    // is it necessary to request a localization file?\n    if ( config.name === loader.defaultLanguage ) {\n        // no\n        prepare();\n        if ( callback !== null ) {\n            callback(null);\n        }\n    } else {\n        xhr = new XMLHttpRequest();\n\n        xhr.onload = function () {\n            var jsonParseError, json;\n\n            try {\n                json = JSON.parse(xhr.responseText);\n            } catch ( error ) {\n                jsonParseError = error;\n            }\n\n            if ( jsonParseError ) {\n                xhr.onerror(jsonParseError);\n            } else {\n                prepare(json);\n                if ( callback !== null ) {\n                    callback(null);\n                }\n\n                // there are some listeners\n                if ( loader.events['load'] ) {\n                    // notify listeners\n                    loader.emit('load');\n                }\n            }\n        };\n\n        xhr.ontimeout = xhr.onerror = function ( error ) {\n            prepare();\n\n            if ( callback !== null ) {\n                callback(null);\n            }\n\n            // there are some listeners\n            if ( loader.events['error'] ) {\n                // notify listeners\n                loader.emit('error', error);\n            }\n        };\n\n        xhr.open('GET', config.path + '/' + config.name + '.' + config.ext, true);\n        xhr.send(null);\n    }\n};\n\n\n// public\nmodule.exports = loader;\n","/**\n * @license The MIT License (MIT)\n * @author Stanislav Kalashnik <darkpark.main@gmail.com>\n */\n\n/* eslint no-path-concat: 0 */\n\n'use strict';\n\n\n/**\n * Translations handler.\n *\n * @constructor\n *\n * @param {Object} config init parameters\n */\nfunction Gettext ( config ) {\n    var data, meta;\n\n    // sanitize\n    config   = config || {};\n    data     = config.data || {};\n    data[''] = data[''] || {};\n\n    // shortcut\n    meta = config.meta;\n\n    /**\n     * Display the native language translation of a textual message.\n     *\n     * @param {string} msgId textual message\n     *\n     * @return {string} translated text\n     */\n    this.gettext = function ( msgId ) {\n        return data[''][msgId] || msgId;\n    };\n\n\n    /**\n     * The \"p\" in \"pgettext\" stands for \"particular\": fetches a particular translation of the textual message.\n     *\n     * @param {string} context message context\n     * @param {string} msgId textual message\n     *\n     * @return {string} translated text\n     */\n    this.pgettext = function ( context, msgId ) {\n        return data[context] && data[context][msgId] || msgId;\n    };\n\n\n    /**\n     * Display the native language translation of a textual message whose grammatical form depends on a number.\n     *\n     * @param {string} msgId textual message in a singular form\n     * @param {string} plural textual message in a plural form\n     * @param {number} value message number\n     *\n     * @return {string} translated text\n     */\n    this.ngettext = function ( msgId, plural, value ) {\n        /* eslint no-unused-vars: 0 */\n        /* eslint no-eval: 0 */\n        /* eslint id-length: 0 */\n        var n, evalResult;\n\n        if ( DEVELOP ) {\n            if ( Number(value) !== value ) {\n                throw new Error(__filename + ': value must be a number');\n            }\n        }\n\n        if ( data && meta && data[''][msgId] ) {\n            evalResult = eval('n = ' + value + '; ' + meta.plural);\n\n            if ( typeof evalResult === 'boolean' ) {\n                evalResult = +evalResult;\n            }\n\n            // translation\n            return data[''][msgId][evalResult];\n        }\n\n        // english\n        return value === 1 ? msgId : plural;\n    };\n}\n\n\n// correct constructor name\nGettext.prototype.constructor = Gettext;\n\n\n// public\nmodule.exports = Gettext;\n","'use strict';\n\n\n/** @namespace */\nmodule.exports = {\n    layouts: {\n        tvChannel: 1, // tv channel item with playback and epg now\n        video: 2,  // moview preview with play now item\n        record: 3, // audio preview with play now item\n        static: 4, // static item by default\n        application: 5\n    },\n    geometry: {\n        square: 1,\n        horizontal: 2,\n        vertical: 3,\n        round: 4\n    },\n    actions: { // actions which can be applied to item\n        favorite: 1,\n        accessControl: 2,\n        expandItemContent: 3\n    }\n};\n"],"sourceRoot":""}
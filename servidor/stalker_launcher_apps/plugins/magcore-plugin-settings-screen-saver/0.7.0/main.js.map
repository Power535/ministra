{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/js/main.js","webpack:///./node_modules/mag-gettext/index.js","webpack:///./node_modules/cjs-emitter/index.js","webpack:///./node_modules/cjs-gettext/index.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","currentInterval","currentSaverPackageName","currentSaverPackage","gettext","gettextWrapper","savers","saversByPackageName","packageNameToPath","onInit","config","callback","load","core","environment","language","path","packages","packageName","packageInfo","Number","storage","getItem","setItem","gSTB","SetScreenSaverTime","packageMap","type","url","push","SetScreenSaverInitAttr","JSON","stringify","backgroundColor","init","onAppInit","onSettingsInit","result","timeToLabel","0","60","300","600","1200","1800","content","id","parent","description","label","icon","data","timeValue","saveImmediate","render","api","renders","popupSelect","prepareForRender","map","item","selected","prepareForSave","this","actions","setInfo","saverName","items","forEach","build","Emitter","Gettext","loader","prepare","_","pgettext","ngettext","defaultLanguage","xhr","ext","XMLHttpRequest","onload","jsonParseError","json","parse","responseText","error","onerror","events","emit","ontimeout","open","send","addListener","once","self","onceWrapper","removeListener","apply","arguments","addListeners","callbacks","filter","fn","length","undefined","index","event","Array","slice","constructor","meta","msgId","context","plural","evalResult","eval"],"mappings":"2BACA,IAAAA,EAAA,GAGA,SAAAC,EAAAC,GAGA,GAAAF,EAAAE,GACA,OAAAF,EAAAE,GAAAC,QAGA,IAAAC,EAAAJ,EAAAE,GAAA,CACAG,EAAAH,EACAI,GAAA,EACAH,QAAA,IAUA,OANAI,EAAAL,GAAAM,KAAAJ,EAAAD,QAAAC,IAAAD,QAAAF,GAGAG,EAAAE,GAAA,EAGAF,EAAAD,QA0DA,OArDAF,EAAAQ,EAAAF,EAGAN,EAAAS,EAAAV,EAGAC,EAAAU,EAAA,SAAAR,EAAAS,EAAAC,GACAZ,EAAAa,EAAAX,EAAAS,IACAG,OAAAC,eAAAb,EAAAS,EAAA,CAA0CK,YAAA,EAAAC,IAAAL,KAK1CZ,EAAAkB,EAAA,SAAAhB,GACA,oBAAAiB,eAAAC,aACAN,OAAAC,eAAAb,EAAAiB,OAAAC,YAAA,CAAwDC,MAAA,WAExDP,OAAAC,eAAAb,EAAA,cAAiDmB,OAAA,KAQjDrB,EAAAsB,EAAA,SAAAD,EAAAE,GAEA,GADA,EAAAA,IAAAF,EAAArB,EAAAqB,IACA,EAAAE,EAAA,OAAAF,EACA,KAAAE,GAAA,iBAAAF,QAAAG,WAAA,OAAAH,EACA,IAAAI,EAAAX,OAAAY,OAAA,MAGA,GAFA1B,EAAAkB,EAAAO,GACAX,OAAAC,eAAAU,EAAA,WAAyCT,YAAA,EAAAK,UACzC,EAAAE,GAAA,iBAAAF,EAAA,QAAAM,KAAAN,EAAArB,EAAAU,EAAAe,EAAAE,EAAA,SAAAA,GAAgH,OAAAN,EAAAM,IAAqBC,KAAA,KAAAD,IACrI,OAAAF,GAIAzB,EAAA6B,EAAA,SAAA1B,GACA,IAAAS,EAAAT,KAAAqB,WACA,WAA2B,OAAArB,EAAA,YAC3B,WAAiC,OAAAA,GAEjC,OADAH,EAAAU,EAAAE,EAAA,IAAAA,GACAA,GAIAZ,EAAAa,EAAA,SAAAiB,EAAAC,GAAsD,OAAAjB,OAAAkB,UAAAC,eAAA1B,KAAAuB,EAAAC,IAGtD/B,EAAAkC,EAAA,GAIAlC,IAAAmC,EAAA,kCC5EA,IAIAC,EAAAC,EAAAC,EAAAC,EAJAC,EAA0BxC,EAAQ,GAClCyC,EAAA,GACAC,EAAA,GACAC,EAAA,GA0MAxC,EAAAD,QAAA,CACA0C,OAAA,SAAAC,EAAAC,GACAN,EAAAO,KAAA,CACApC,KAAAqC,KAAAC,YAAAC,SACAC,KAAAN,EAAAM,KAAA,QACS,WACTZ,EAAAC,EAAAD,QA7MA,SAAAM,GACA,IAAAO,EAAAC,EAAAC,EAkBA,IAAAD,KAfAjB,EAAAmB,OAAAV,EAAAW,QAAAC,QAAA,gBACA,IAAArB,IAEAA,EAAA,IACAS,EAAAW,QAAAE,QAAA,YAAAtB,IAKAuB,KAAAC,mBAAAxB,GAGAC,EAAAQ,EAAAW,QAAAC,QAAA,aACAL,EAAAJ,KAAAa,WAGAT,EAAAnB,eAAAoB,IAAAD,EAAAC,GAAAS,MAAA,iBAAAV,EAAAC,GAAAS,OACAR,EAAA,CACA3C,KAAAqC,KAAAa,WAAAR,GAAA1C,KACAwC,KAAAH,KAAAa,WAAAR,GAAAU,IACAV,YAAAL,KAAAa,WAAAR,gBAOAZ,EAAAuB,KAAAV,GACAZ,EAAAY,EAAAD,aAAAC,EACAX,EAAAK,KAAAa,WAAAR,gBAAAC,EAAAH,KACAd,IAAAiB,EAAAD,cACAf,EAAAgB,KAKAjB,GAAAI,EAAA,KAIAJ,EAAAI,EAAA,GAAAY,YACAf,EAAAG,EAAA,GACAI,EAAAW,QAAAE,QAAA,YAAArB,IAGAA,EAIAsB,KAAAM,uBAAAC,KAAAC,UAAA,CACAJ,IAAApB,EAAAN,GACA+B,gBAAA,UAOAT,KAAAC,mBAAA,GAgJAS,CAAAxB,GACAC,OAGAwB,UAAA,SAAAzB,EAAAC,GACAA,EAAA,UAEAyB,eAAA,SAAA1B,EAAAC,GACAA,EAAA,KAnJA,SAAAD,GACA,IAQA2B,EARAC,EAAA,CACAC,EAAAnC,EAAA,YACAoC,GAAApC,EAAA,YACAqC,IAAArC,EAAA,aACAsC,IAAAtC,EAAA,cACAuC,KAAAvC,EAAA,cACAwC,KAAAxC,EAAA,eAyHA,OApHAiC,EADAnC,EACA,CACA2C,QAAA,CACA,CACAC,GAAA,sBACAC,OAAA,gBACApB,KAAA,SACAnD,KAAA4B,EAAA,wBACA4C,YAAA,CACA,CACAC,MAAA7C,EAAA,gBACAlB,MAAAoD,EAAArC,IAAA,IACyB,CACzBgD,MAAA,GACA/D,MAAAkB,EAAA,+EAGA8C,KAAA,kCACAC,KAAA,CAA2BC,UAAA,KAC3BC,eAAA,EACAC,OAAA5C,EAAA6C,IAAAC,QAAAC,YACAC,iBAAA,SAAAP,EAAAxC,GACAA,EACA,yBAAAgD,IAAA,SAAAC,GACA,OAAwC1E,MAAA0E,EAAApF,KAAA8D,EAAAsB,GAAAC,SAAA5D,IAAA2D,OAIxCE,eAAA,SAAA5E,EAAAyB,GAIAV,EAAAf,EACA6E,KAAAZ,KAAAC,UAAAnD,EACAuB,KAAAC,mBAAAxB,GACAU,EAAA,gBACAD,EAAA6C,IAAAS,QAAAC,QAAA,CACAjB,YAAA,CACA,CACAC,MAAA7C,EAAA,gBACAlB,MAAAoD,EAAArC,IAAA,IACqC,CACrCgD,MAAA,GACA/D,MAAAkB,EAAA,iFAIAiC,KAAAQ,SAAAR,EAAAQ,QAAA,IAAAR,EAAAQ,QAAA,GAAAG,cACAX,EAAAQ,QAAA,GAAAG,YAAA,GAAA9D,MAAAoD,EAAArC,IAAA,QAKA,CACA6C,GAAA,oBACAC,OAAA,gBACApB,KAAA,SACAnD,KAAA4B,EAAA,eACA4C,YAAA,CACA,CACAC,MAAA7C,EAAA,YACAlB,MAAAiB,EAAA3B,MACyB,CACzByE,MAAA,GACA/D,MAAAkB,EAAA,mCAGA8C,KAAA,yBACAC,KAAA,CAA2Be,UAAA,IAC3Bb,eAAA,EACAC,OAAA5C,EAAA6C,IAAAC,QAAAC,YACAC,iBAAA,SAAAP,EAAAxC,GACA,IAAAwD,EAAA,GAEA7D,EAAA8D,QAAA,SAAAR,GACAO,EAAAtC,KAAA,CACA3C,MAAA0E,EAAA1C,YACA1C,KAAAoF,EAAApF,KACAqF,SAAAD,EAAA1C,cAAAhB,MAGAS,EAAAwD,IAEAL,eAAA,SAAA5E,EAAAyB,GAKAT,EAAAK,EAAArB,GAAAgC,YACAf,EAAAI,EAAArB,GACA6E,KAAAZ,KAAAe,UAAAhE,EACAsB,KAAAM,uBAAAC,KAAAC,UAAA,CACAJ,IAAApB,EAAAN,GACA+B,gBAAA,UAEAtB,EAAA,gBACAD,EAAA6C,IAAAS,QAAAC,QAAA,CACAjB,YAAA,CACA,CAAqCC,MAAA7C,EAAA,YAAAlB,MAAAiB,EAAA3B,MACrC,CAAqCyE,MAAA,GAAA/D,MAAAkB,EAAA,qCAGrCiC,KAAAQ,SAAAR,EAAAQ,QAAA,IAAAR,EAAAQ,QAAA,GAAAG,cACAX,EAAAQ,QAAA,GAAAG,YAAA,GAAA9D,MAAAiB,EAAA3B,YAQA,CAAkBqE,QAAA,IAyBlBwB,CAAA3D,oCCzNA,IAAA4D,EAAczG,EAAQ,GACtB0G,EAAc1G,EAAQ,GACtB2G,EAAA,IAAAF,EAeA,SAAAG,EAAAtB,GACA,IAAA/C,EAAA,IAAAmE,EAAApB,GAEAqB,EAAAE,EAAAF,EAAApE,kBACAoE,EAAAG,SAAAvE,EAAAuE,SACAH,EAAAI,SAAAxE,EAAAwE,SAOAJ,EAAAK,gBAAA,KAYAL,EAAA5D,KAAA,SAAAF,EAAAC,GACA,IAAAmE,EAaAnE,KAAA,KACAD,EAAAqE,IAAArE,EAAAqE,KAAA,OACArE,EAAAM,KAAAN,EAAAM,MAAA,OAGAN,EAAAlC,OAAAgG,EAAAK,iBAEAJ,IACA,OAAA9D,GACAA,EAAA,SAGAmE,EAAA,IAAAE,gBAEAC,OAAA,WACA,IAAAC,EAAAC,EAEA,IACAA,EAAApD,KAAAqD,MAAAN,EAAAO,cACa,MAAAC,GACbJ,EAAAI,EAGAJ,EACAJ,EAAAS,QAAAL,IAEAT,EAAAU,GACA,OAAAxE,GACAA,EAAA,MAIA6D,EAAAgB,OAAA,SAEAhB,EAAAiB,KAAA,UAKAX,EAAAY,UAAAZ,EAAAS,QAAA,SAAAD,GACAb,IAEA,OAAA9D,GACAA,EAAA,MAIA6D,EAAAgB,OAAA,UAEAhB,EAAAiB,KAAA,QAAAH,IAIAR,EAAAa,KAAA,MAAAjF,EAAAM,KAAA,IAAAN,EAAAlC,KAAA,IAAAkC,EAAAqE,KAAA,GACAD,EAAAc,KAAA,QAMA5H,EAAAD,QAAAyG,gCCzGA,SAAAF,IAwBAP,KAAAyB,OAAA,GAIAlB,EAAAzE,UAAA,CAaAgG,YAAA,SAAArH,EAAAmC,GAaAoD,KAAAyB,OAAAhH,GAAAuF,KAAAyB,OAAAhH,IAAA,GAEAuF,KAAAyB,OAAAhH,GAAAqD,KAAAlB,IAcAmF,KAAA,SAAAtH,EAAAmC,GAEA,IAAAoF,EAAAhC,KAeAA,KAAAyB,OAAAhH,GAAAuF,KAAAyB,OAAAhH,IAAA,GAEAuF,KAAAyB,OAAAhH,GAAAqD,KAAA,SAAAmE,IACAD,EAAAE,eAAAzH,EAAAwH,GACArF,EAAAuF,MAAAH,EAAAI,cAgBAC,aAAA,SAAAC,GACA,IAAA7H,EAcA,IAAAA,KAAA6H,EACAA,EAAAvG,eAAAtB,IACAuF,KAAA8B,YAAArH,EAAA6H,EAAA7H,KAeAyH,eAAA,SAAAzH,EAAAmC,GAiBAoD,KAAAyB,OAAAhH,KAEAuF,KAAAyB,OAAAhH,GAAAuF,KAAAyB,OAAAhH,GAAA8H,OAAA,SAAAC,GAA0F,OAAAA,IAAA5F,IAE1F,IAAAoD,KAAAyB,OAAAhH,GAAAgI,SAEAzC,KAAAyB,OAAAhH,QAAAiI,KAwDAhB,KAAA,SAAAjH,GACA,IACAkI,EADAC,EAAA5C,KAAAyB,OAAAhH,GAaA,GAAAmI,EAOA,IAAAD,EAAA,EAA4BA,EAAAC,EAAAH,OAAsBE,IAQlDC,EAAAD,GAAAR,MAAAnC,KAAA6C,MAAA/G,UAAAgH,MAAAzI,KAAA+H,UAAA,MAQA7B,EAAAzE,UAAAiH,YAAAxC,EAIAtG,EAAAD,QAAAuG,6DCrQA,SAAAC,QAAA7D,QACA,IAAAyC,KAAA4D,KAGArG,eAAA,GACAyC,KAAAzC,OAAAyC,MAAA,GACAA,KAAA,IAAAA,KAAA,QAGA4D,KAAArG,OAAAqG,KASAhD,KAAA3D,QAAA,SAAA4G,GACA,OAAA7D,KAAA,IAAA6D,OAYAjD,KAAAY,SAAA,SAAAsC,EAAAD,GACA,OAAA7D,KAAA8D,IAAA9D,KAAA8D,GAAAD,OAaAjD,KAAAa,SAAA,SAAAoC,MAAAE,OAAAhI,OAIA,IAAAQ,EAAAyH,WAQA,OAAAhE,MAAA4D,MAAA5D,KAAA,IAAA6D,QACAG,WAAAC,KAAA,OAAAlI,MAAA,KAAiD6H,KAAAG,QAEjD,kBAAAC,aACAA,wBAIAhE,KAAA,IAAA6D,OAAAG,aAIA,IAAAjI,MAAA8H,MAAAE,QAMA3C,QAAA1E,UAAAiH,YAAAvC,QAIAvG,OAAAD,QAAAwG","file":"main.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","/**\n * Created by bas.\n */\n\n'use strict';\n\nvar gettextWrapper      = require('mag-gettext'),\n    savers              = [],\n    saversByPackageName = {},\n    packageNameToPath   = {},\n    currentInterval, currentSaverPackageName, currentSaverPackage, gettext;\n\nfunction init ( config ) {\n    var packages, packageName, packageInfo;\n\n    // apply interval settings\n    currentInterval = Number(config.storage.getItem('timeValue'));\n    if ( !currentInterval && currentInterval !== 0 ) {\n        // default time 5 minutes\n        currentInterval = 300;\n        config.storage.setItem('timeValue', currentInterval);\n    }\n    if ( DEVELOP ) {\n        console.log(currentInterval ? 'screen saver interval ' + currentInterval : 'screen saver turned off');\n    }\n    gSTB.SetScreenSaverTime(currentInterval);\n\n    // activate selected screen saver view\n    currentSaverPackageName = config.storage.getItem('saverName');\n    packages = core.packageMap;\n\n    for ( packageName in packages ) {\n        if ( packages.hasOwnProperty(packageName) && packages[packageName].type && packages[packageName].type === 'screen-saver' ) {\n            packageInfo = {\n                name:        core.packageMap[packageName].name,\n                path:        core.packageMap[packageName].url,\n                packageName: core.packageMap[packageName].packageName\n            };\n            if ( DEVELOP ) {\n                console.log('Screen saver package found:');\n                console.log('name ' + packageInfo.name);\n                console.log('path ' + packageInfo.path);\n            }\n            savers.push(packageInfo);\n            saversByPackageName[packageInfo.packageName] = packageInfo;\n            packageNameToPath[core.packageMap[packageName].packageName] = packageInfo.path;\n            if ( currentSaverPackageName === packageInfo.packageName ) {\n                currentSaverPackage = packageInfo;\n            }\n        }\n    }\n    // current screen saver not found in list - use first one\n    if ( !currentSaverPackageName && savers[0] ) {\n        if ( DEVELOP ) {\n            console.log('selected screen saver package not found, use first one: ' + savers[0].packageName);\n        }\n        currentSaverPackageName = savers[0].packageName;\n        currentSaverPackage = savers[0];\n        config.storage.setItem('saverName', currentSaverPackageName);\n    }\n\n    if ( currentSaverPackageName ) {\n        if ( DEVELOP ) {\n            console.log('set screen saver path to: ' + packageNameToPath[currentSaverPackageName]);\n        }\n        gSTB.SetScreenSaverInitAttr(JSON.stringify({\n            url: packageNameToPath[currentSaverPackageName],\n            backgroundColor: '#000'\n        }));\n    } else {\n        // can't find any screen saver, turn off\n        if ( DEVELOP ) {\n            console.log('none screen saver package was found, turn off');\n        }\n        gSTB.SetScreenSaverTime(0);\n    }\n}\n\n\nfunction build ( config ) {\n    var timeToLabel = {\n            0:    gettext('Disabled'),\n            60:   gettext('1 minute'),\n            300:  gettext('5 minutes'),\n            600:  gettext('10 minutes'),\n            1200: gettext('20 minutes'),\n            1800: gettext('30 minutes')\n        },\n        result;\n\n    if ( currentSaverPackageName ) {\n        result = {\n            content: [\n                {\n                    id: 'screenSaverInterval',\n                    parent: 'userInterface',\n                    type: 'option',\n                    name: gettext('Screensaver interval'),\n                    description: [\n                        {\n                            label: gettext('Interval') + ':',\n                            value: timeToLabel[currentInterval] || ''\n                        }, {\n                            label: '',\n                            value: gettext('The duration of the device inactivity, upon which appears the screensaver')\n                        }\n                    ],\n                    icon: 'theme-icon-screensaver-interval',\n                    data: {timeValue: 300},\n                    saveImmediate: true,\n                    render: config.api.renders.popupSelect,\n                    prepareForRender: function ( data, callback ) {\n                        callback(\n                            [0, 60, 300, 600, 1200, 1800].map(function ( item ) {\n                                return {value: item, name: timeToLabel[item], selected: currentInterval === item};\n                            })\n                        );\n                    },\n                    prepareForSave: function ( value, callback ) {\n                        if ( DEVELOP ) {\n                            console.log('interval changed, was ' + config.storage.getItem('timeValue') + ' set to ' + value);\n                        }\n                        currentInterval = value;\n                        this.data.timeValue = currentInterval;\n                        gSTB.SetScreenSaverTime(currentInterval);\n                        callback(null, function () {\n                            config.api.actions.setInfo({\n                                description: [\n                                    {\n                                        label: gettext('Interval') + ':',\n                                        value: timeToLabel[currentInterval] || ''\n                                    }, {\n                                        label: '',\n                                        value: gettext('The duration of the device inactivity, upon which appears the screensaver')\n                                    }\n                                ]\n                            });\n                            if ( result && result.content && result.content[0] && result.content[0].description ) {\n                                result.content[0].description[0].value = timeToLabel[currentInterval] || '';\n                            }\n                        });\n                    }\n                },\n                {\n                    id: 'screenSaverSelect',\n                    parent: 'userInterface',\n                    type: 'option',\n                    name: gettext('Screensaver'),\n                    description: [\n                        {\n                            label: gettext('Name') + ':',\n                            value: currentSaverPackage.name\n                        }, {\n                            label: '',\n                            value: gettext('Choosing a splash Screensaver')\n                        }\n                    ],\n                    icon: 'theme-icon-screensaver',\n                    data: {saverName: ''},\n                    saveImmediate: true,\n                    render: config.api.renders.popupSelect,\n                    prepareForRender: function ( data, callback ) {\n                        var items = [];\n\n                        savers.forEach(function ( item ) {\n                            items.push({\n                                value:    item.packageName,\n                                name:     item.name,\n                                selected: item.packageName === currentSaverPackageName\n                            });\n                        });\n                        callback(items);\n                    },\n                    prepareForSave: function ( value, callback ) {\n                        if ( DEVELOP ) {\n                            console.log('package changed, was ' + config.storage.getItem('saverName') + ', set to ' + value);\n                            console.log('saversByName: ' + JSON.stringify(saversByPackageName));\n                        }\n                        currentSaverPackageName = saversByPackageName[value].packageName;\n                        currentSaverPackage = saversByPackageName[value];\n                        this.data.saverName = currentSaverPackageName;\n                        gSTB.SetScreenSaverInitAttr(JSON.stringify({\n                            url: packageNameToPath[currentSaverPackageName],\n                            backgroundColor: '#000'\n                        }));\n                        callback(null, function () {\n                            config.api.actions.setInfo({\n                                description: [\n                                    {label: gettext('Name') + ':', value: currentSaverPackage.name},\n                                    {label: '', value: gettext('Choosing a splash Screensaver')}\n                                ]\n                            });\n                            if ( result && result.content && result.content[1] && result.content[1].description ) {\n                                result.content[1].description[0].value = currentSaverPackage.name;\n                            }\n                        });\n                    }\n                }\n            ]\n        };\n    } else {\n        result = {content: []};\n        if ( DEVELOP ) {\n            console.log('can\\'t find any screen saver package! Hiding screen saver settings.');\n        }\n    }\n\n    return result;\n}\n\n\nmodule.exports = {\n    onInit: function ( config, callback ) {\n        gettextWrapper.load({\n            name: core.environment.language,\n            path: config.path + 'lang'\n        }, function () {\n            gettext = gettextWrapper.gettext;\n            init(config);\n            callback();\n        });\n    },\n    onAppInit: function ( config, callback ) {\n        callback(null, {});\n    },\n    onSettingsInit: function ( config, callback ) {\n        callback(null, build(config));\n    }\n};\n","/**\n * @license The MIT License (MIT)\n * @copyright Stanislav Kalashnik <darkpark.main@gmail.com>\n */\n\n/* eslint no-path-concat: 0 */\n\n'use strict';\n\nvar Emitter = require('cjs-emitter'),\n    Gettext = require('cjs-gettext'),\n    loader  = new Emitter();\n\n\nif ( DEVELOP ) {\n    loader._ = loader.gettext = loader.pgettext = loader.ngettext = function () {\n        throw new Error(__filename + ': you cannot use this function before mag-gettext not yet loaded');\n    };\n}\n\n/**\n * Wrap the given data with gettext instance\n * and export methods to the global scope.\n *\n * @param {Object} [data] localization data\n */\nfunction prepare ( data ) {\n    var gettext = new Gettext(data);\n\n    loader._ = loader.gettext = gettext.gettext;\n    loader.pgettext = gettext.pgettext;\n    loader.ngettext = gettext.ngettext;\n}\n\n\n/**\n * Main application language\n */\nloader.defaultLanguage = 'en';\n\n\n/**\n * Simple gettext implementation.\n *\n * @param {Object} config options\n * @param {string} [config.path=lang] relative path to project root\n * @param {string} config.name language name\n * @param {string} [config.ext=json] language file extension\n * @param {function} callback hook on ready\n */\nloader.load = function ( config, callback ) {\n    var xhr;\n\n    if ( DEVELOP ) {\n        if ( !config.name || typeof config.name !== 'string' ) {\n            throw new Error(__filename + ': config.name must be a nonempty string');\n        }\n        if ( callback && typeof callback !== 'function' ) {\n            throw new Error(__filename + ': wrong callback type');\n        }\n    }\n\n    // defaults\n\n    callback = callback || null;\n    config.ext  = config.ext  || 'json';\n    config.path = config.path || 'lang';\n\n    // is it necessary to request a localization file?\n    if ( config.name === loader.defaultLanguage ) {\n        // no\n        prepare();\n        if ( callback !== null ) {\n            callback(null);\n        }\n    } else {\n        xhr = new XMLHttpRequest();\n\n        xhr.onload = function () {\n            var jsonParseError, json;\n\n            try {\n                json = JSON.parse(xhr.responseText);\n            } catch ( error ) {\n                jsonParseError = error;\n            }\n\n            if ( jsonParseError ) {\n                xhr.onerror(jsonParseError);\n            } else {\n                prepare(json);\n                if ( callback !== null ) {\n                    callback(null);\n                }\n\n                // there are some listeners\n                if ( loader.events['load'] ) {\n                    // notify listeners\n                    loader.emit('load');\n                }\n            }\n        };\n\n        xhr.ontimeout = xhr.onerror = function ( error ) {\n            prepare();\n\n            if ( callback !== null ) {\n                callback(null);\n            }\n\n            // there are some listeners\n            if ( loader.events['error'] ) {\n                // notify listeners\n                loader.emit('error', error);\n            }\n        };\n\n        xhr.open('GET', config.path + '/' + config.name + '.' + config.ext, true);\n        xhr.send(null);\n    }\n};\n\n\n// public\nmodule.exports = loader;\n","/**\n * @license The MIT License (MIT)\n * @author Stanislav Kalashnik <darkpark.main@gmail.com>\n */\n\n/* eslint no-path-concat: 0 */\n\n'use strict';\n\n\n/**\n * Base Events Emitter implementation.\n *\n * @see http://nodejs.org/api/events.html\n * @constructor\n *\n * @example\n * var emitter = new Emitter();\n */\nfunction Emitter () {\n    console.assert(typeof this === 'object', 'must be constructed via new');\n\n    // if ( DEVELOP ) {\n    //     if ( typeof this !== 'object' ) { throw new Error(__filename + ': must be constructed via new'); }\n    // }\n\n    /**\n     * Inner hash table for event names and linked callbacks.\n     * Manual editing should be avoided.\n     *\n     * @member {Object.<string, function[]>}\n     *\n     * @example\n     * {\n     *     click: [\n     *         function click1 () { ... },\n     *         function click2 () { ... }\n     *     ],\n     *     keydown: [\n     *         function () { ... }\n     *     ]\n     * }\n     **/\n    this.events = {};\n}\n\n\nEmitter.prototype = {\n    /**\n     * Bind an event to the given callback function.\n     * The same callback function can be added multiple times for the same event name.\n     *\n     * @param {string} name event identifier\n     * @param {function} callback function to call on this event\n     *\n     * @example\n     * emitter.addListener('click', function ( data ) { ... });\n     * // one more click handler\n     * emitter.addListener('click', function ( data ) { ... });\n     */\n    addListener: function ( name, callback ) {\n        console.assert(arguments.length === 2, 'wrong arguments number');\n        console.assert(typeof name === 'string', 'wrong name type');\n        console.assert(name.length > 0, 'empty name');\n        console.assert(typeof callback === 'function', 'callback should be a function');\n\n        // if ( DEVELOP ) {\n        //     if ( arguments.length !== 2 ) { throw new Error(__filename + ': wrong arguments number'); }\n        //     if ( typeof name !== 'string' || name.length === 0 ) { throw new Error(__filename + ': wrong or empty name'); }\n        //     if ( typeof callback !== 'function' ) { throw new Error(__filename + ': wrong callback type'); }\n        // }\n\n        // initialization may be required\n        this.events[name] = this.events[name] || [];\n        // append this new event to the list\n        this.events[name].push(callback);\n    },\n\n\n    /**\n     * Add a one time listener for the event.\n     * This listener is invoked only the next time the event is fired, after which it is removed.\n     *\n     * @param {string} name event identifier\n     * @param {function} callback function to call on this event\n     *\n     * @example\n     * emitter.once('click', function ( data ) { ... });\n     */\n    once: function ( name, callback ) {\n        // current execution context\n        var self = this;\n\n        if ( DEVELOP ) {\n            if ( arguments.length !== 2 ) {\n                throw new Error(__filename + ': wrong arguments number');\n            }\n            if ( typeof name !== 'string' || name.length === 0 ) {\n                throw new Error(__filename + ': wrong or empty name');\n            }\n            if ( typeof callback !== 'function' ) {\n                throw new Error(__filename + ': wrong callback type');\n            }\n        }\n\n        // initialization may be required\n        this.events[name] = this.events[name] || [];\n        // append this new event to the list\n        this.events[name].push(function onceWrapper () {\n            self.removeListener(name, onceWrapper);\n            callback.apply(self, arguments);\n        });\n    },\n\n\n    /**\n     * Apply multiple listeners at once.\n     *\n     * @param {Object} callbacks event names with callbacks\n     *\n     * @example\n     * emitter.addListeners({\n     *     click: function ( data ) {},\n     *     close: function ( data ) {}\n     * });\n     */\n    addListeners: function ( callbacks ) {\n        var name;\n\n        if ( DEVELOP ) {\n            if ( arguments.length !== 1 ) {\n                throw new Error(__filename + ': wrong arguments number');\n            }\n            if ( typeof callbacks !== 'object' ) {\n                throw new Error(__filename + ': wrong callbacks type');\n            }\n            if ( Object.keys(callbacks).length === 0 ) {\n                throw new Error(__filename + ': no callbacks given');\n            }\n        }\n\n        for ( name in callbacks ) {\n            if ( callbacks.hasOwnProperty(name) ) {\n                this.addListener(name, callbacks[name]);\n            }\n        }\n    },\n\n\n    /**\n     * Remove all instances of the given callback.\n     *\n     * @param {string} name event identifier\n     * @param {function} callback function to remove\n     *\n     * @example\n     * emitter.removeListener('click', func1);\n     */\n    removeListener: function ( name, callback ) {\n        if ( DEVELOP ) {\n            if ( arguments.length !== 2 ) {\n                throw new Error(__filename + ': wrong arguments number');\n            }\n            if ( typeof name !== 'string' || name.length === 0 ) {\n                throw new Error(__filename + ': wrong or empty name');\n            }\n            if ( typeof callback !== 'function' ) {\n                throw new Error(__filename + ': wrong callback type');\n            }\n            if ( this.events[name] && !Array.isArray(this.events[name]) ) {\n                throw new Error(__filename + ': corrupted inner data');\n            }\n        }\n\n        // the event exists and should have some callbacks\n        if ( this.events[name] ) {\n            // rework the callback list to exclude the given one\n            this.events[name] = this.events[name].filter(function callbacksFilter ( fn ) { return fn !== callback; });\n            // event has no more callbacks so clean it\n            if ( this.events[name].length === 0 ) {\n                // as if there were no listeners at all\n                this.events[name] = undefined;\n            }\n        }\n    },\n\n\n    /**\n     * Remove all callbacks for the given event name.\n     * Without event name clears all events.\n     *\n     * @param {string} [name] event identifier\n     *\n     * @example\n     * emitter.removeAllListeners('click');\n     * emitter.removeAllListeners();\n     *\n     * @deprecated\n     */\n    /*removeAllListeners: function ( name ) {\n        if ( DEVELOP ) {\n            if ( arguments.length !== 0 && (typeof name !== 'string' || name.length === 0) ) {\n                throw new Error(__filename + ': wrong or empty name');\n            }\n        }\n\n        // check input\n        if ( arguments.length === 0 ) {\n            // no arguments so remove everything\n            this.events = {};\n        } else if ( name ) {\n            if ( DEVELOP ) {\n                if ( this.events[name] ) { throw new Error(__filename + ': event is not removed'); }\n            }\n\n            // only name is given so remove all callbacks for the given event\n            // but object structure modification should be avoided\n            this.events[name] = undefined;\n        }\n    },*/\n\n\n    /**\n     * Execute each of the listeners in the given order with the supplied arguments.\n     *\n     * @param {string} name event identifier\n     *\n     * @example\n     * emitter.emit('init');\n     * emitter.emit('click', {src: panel1, dst: panel2});\n     * emitter.emit('load', error, data);\n     *\n     * // it's a good idea to emit event only when there are some listeners\n     * if ( this.events['click'] ) {\n     *     this.emit('click', {event: event});\n     * }\n     */\n    emit: function ( name ) {\n        var event = this.events[name],\n            index;\n\n        if ( DEVELOP ) {\n            if ( arguments.length < 1 ) {\n                throw new Error(__filename + ': wrong arguments number');\n            }\n            if ( typeof name !== 'string' || name.length === 0 ) {\n                throw new Error(__filename + ': wrong or empty name');\n            }\n        }\n\n        // the event exists and should have some callbacks\n        if ( event ) {\n            if ( DEVELOP ) {\n                if ( !Array.isArray(event) ) {\n                    throw new Error(__filename + ': wrong event type');\n                }\n            }\n\n            for ( index = 0; index < event.length; index++ ) {\n                if ( DEVELOP ) {\n                    if ( typeof event[index] !== 'function' ) {\n                        throw new Error(__filename + ': wrong event callback type');\n                    }\n                }\n\n                // invoke the callback with parameters\n                event[index].apply(this, Array.prototype.slice.call(arguments, 1));\n            }\n        }\n    }\n};\n\n\n// correct constructor name\nEmitter.prototype.constructor = Emitter;\n\n\n// public\nmodule.exports = Emitter;\n","/**\n * @license The MIT License (MIT)\n * @author Stanislav Kalashnik <darkpark.main@gmail.com>\n */\n\n/* eslint no-path-concat: 0 */\n\n'use strict';\n\n\n/**\n * Translations handler.\n *\n * @constructor\n *\n * @param {Object} config init parameters\n */\nfunction Gettext ( config ) {\n    var data, meta;\n\n    // sanitize\n    config   = config || {};\n    data     = config.data || {};\n    data[''] = data[''] || {};\n\n    // shortcut\n    meta = config.meta;\n\n    /**\n     * Display the native language translation of a textual message.\n     *\n     * @param {string} msgId textual message\n     *\n     * @return {string} translated text\n     */\n    this.gettext = function ( msgId ) {\n        return data[''][msgId] || msgId;\n    };\n\n\n    /**\n     * The \"p\" in \"pgettext\" stands for \"particular\": fetches a particular translation of the textual message.\n     *\n     * @param {string} context message context\n     * @param {string} msgId textual message\n     *\n     * @return {string} translated text\n     */\n    this.pgettext = function ( context, msgId ) {\n        return data[context] && data[context][msgId] || msgId;\n    };\n\n\n    /**\n     * Display the native language translation of a textual message whose grammatical form depends on a number.\n     *\n     * @param {string} msgId textual message in a singular form\n     * @param {string} plural textual message in a plural form\n     * @param {number} value message number\n     *\n     * @return {string} translated text\n     */\n    this.ngettext = function ( msgId, plural, value ) {\n        /* eslint no-unused-vars: 0 */\n        /* eslint no-eval: 0 */\n        /* eslint id-length: 0 */\n        var n, evalResult;\n\n        if ( DEVELOP ) {\n            if ( Number(value) !== value ) {\n                throw new Error(__filename + ': value must be a number');\n            }\n        }\n\n        if ( data && meta && data[''][msgId] ) {\n            evalResult = eval('n = ' + value + '; ' + meta.plural);\n\n            if ( typeof evalResult === 'boolean' ) {\n                evalResult = +evalResult;\n            }\n\n            // translation\n            return data[''][msgId][evalResult];\n        }\n\n        // english\n        return value === 1 ? msgId : plural;\n    };\n}\n\n\n// correct constructor name\nGettext.prototype.constructor = Gettext;\n\n\n// public\nmodule.exports = Gettext;\n"],"sourceRoot":""}
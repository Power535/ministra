{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/js/main.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","SMB_PATH","SMB_MOUNTED","apiVersion","gSTB","Version","split","trim","asyncApiAvail","cache","enabled","workers","activeGroup","activeServer","data","groups","servers","shares","groupsCacheTime","serversCacheTime","sharesCacheTime","setup","worker","this","indexOf","push","setupTime","Date","clear","forEach","mountSmb","config","login","password","command","status","address","charAt","length","substr","mountPath","RDir","getGroups","callback","useCache","self","Error","iterateGroups","group","uri","type","types","SAMBA_GROUP","keys","window","stbSmb","findGroups","error","Array","isArray","message","JSON","parse","GetSmbGroups","result","getServers","iterateServers","server","SAMBA_HOST","findServers","GetSmbServers","stringify","getShares","iterateShares","ips","share","addresses","findShares","findIp","findIps","GetSmbShares","serverIP","concat","additionalIPs","openShare","idx","folder","setTimeout","onAppInit","app","SAMBA_SHARE","clearCache"],"mappings":"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","file":"main.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","/**\n * MAGCORE implementation of SMB/CIFS network plugin.\n *\n * There are different realizations of core SMB API -- old synchronous API and new asynchronous,\n * with callback-based asynchronous model. Plugin realization supports two variations for backward compatibility.\n *\n * @author Yaroslav Surilov <y.surilov@infomir.com>\n */\n\n'use strict';\n\nvar SMB_PATH      = '/ram/mnt/smb', // default dir for SAMBA mount point\n    SMB_MOUNTED   = false,          // flag is a SAMBA share mounted to the SMB_PATH\n    apiVersion    = +gSTB.Version().split(';')[0].split(':')[1].trim(),\n    asyncApiAvail = false,\n    /**\n     * @namespace\n     * @property {boolean} enabled enable/disable cache entirely\n     * @property {string} activeGroup currently opened group\n     * @property {string} activeServer currently opened server\n     * @property {Object} data all cached resources: groups, servers and shares\n     * @property {number} groupsCacheTime value in seconds of lifetime of SAMBA work groups cache\n     * @property {number} serversCacheTime value in seconds of lifetime of SAMBA servers cache\n     * @property {number} sharesCacheTime value in seconds of lifetime of SAMBA shares cache\n     * @property {function} setup\n     */\n    cache = {\n        enabled: true,\n        workers: [],\n        activeGroup: null,\n        activeServer: null,\n        /**\n         * @example\n         * {\n         *     groups: [group_0, group_1, ...],\n         *     servers: {\n         *         group_0: [server_0, server_1, ...],\n         *         group_1: [server_0, server_1, ...]\n         *     },\n         *     shares: {\n         *         server_0: [share_0, share_1, ...],\n         *         server_1: [share_0, share_1, ...]\n         *     }\n         * }\n         */\n        data: {\n            groups: null,\n            servers: null,\n            shares: null\n        },\n        groupsCacheTime: 3600,\n        serversCacheTime: 300,\n        sharesCacheTime: 300,\n        setup: function ( worker ) {\n            if ( this.workers.indexOf(worker) === -1 ) {\n                this.workers.push(worker);\n            }\n\n            worker.setupTime = new Date();\n        },\n        clear: function () {\n            cache.data.groups = null;\n            cache.data.servers = null;\n            cache.data.shares = null;\n            cache.activeGroup = null;\n            cache.activeServer = null;\n\n            cache.workers.forEach(function ( worker ) {\n                delete worker.setupTime;\n            });\n\n            cache.workers = [];\n        }\n    };\n\n// global object is presented and STB API version is appropriate\n// go into new async realization\nif ( window.stbSmb && apiVersion >= 342 ) {\n    asyncApiAvail = true;\n}\n\n\n/**\n * Mount SAMBA shared directory.\n *\n * @param {Object} config mount options\n * @param {string} config.address ip address\n * @param {string} [config.login] needed login\n * @param {string} [config.password] needed password\n * @param {string} [config.mountPath] path to mount point\n */\nfunction mountSmb ( config ) {\n    var login,\n        password,\n        command,\n        status;\n\n    if ( config && config.address ) {\n        config.address = config.address.charAt(config.address.length - 1) === '/' ?\n            config.address.substr(0, config.address.length - 1) :\n            config.address;\n        login = config.login || 'guest';\n        password = config.password ||  '';\n        command = 'mount cifs \"' + config.address + '\" \"' + (config.mountPath || SMB_PATH) + '\" username=' + login +\n            ',password=' + password + ',iocharset=utf8'; //,unc=' + config.address.replace(/\\//g, '\\\\\\\\');\n        status = gSTB.RDir(command).trim();\n        SMB_MOUNTED = status === 'Ok';\n    }\n}\n\n\n/**\n * Fetch available Samba work groups.\n * Realize polymorphic behaviour.\n *\n * @param {function} callback scan result handler\n * @param {boolean} useCache enable/disable caching for this worker\n */\nfunction getGroups ( callback, useCache ) {\n    var data, self, groups;\n\n    if ( typeof callback !== 'function' ) {\n        throw new Error('[Network]::getGroups()> callback must be a function');\n    }\n\n    useCache = typeof useCache === typeof true ? useCache : true;\n\n    if ( cache.enabled && useCache ) {\n        if ( !cache.data.groups ) {\n            cache.setup(getGroups);\n        } else if ( (new Date() - getGroups.setupTime) / 1000 > cache.groupsCacheTime ) {\n            cache.setup(getGroups);\n            // reset data\n            cache.data.groups = null;\n            cache.activeGroup = null;\n        } else {\n            callback(null, cache.data.groups);\n\n            return;\n        }\n    }\n\n    data = [];\n    self = this; // eslint-disable-line\n\n\n    /**\n     * Iterate through SAMBA groups.\n     *\n     * @param {Object[]} groups retrieved SAMBA groups\n     */\n    function iterateGroups ( groups ) {\n        groups.forEach(function ( group ) {\n            if ( group ) {\n                data.push({\n                    name: group,\n                    uri: group,\n                    type: self.types.SAMBA_GROUP\n                });\n            }\n        });\n\n        callback(null, cache.data.groups = data);\n\n        if ( cache.data.servers ) {\n            Object.keys(cache.data.servers).forEach(function ( key ) {\n                if ( groups.indexOf(key) === -1 ) {\n                    delete cache.data.servers[key];\n                }\n            });\n        }\n    }\n\n\n    if ( asyncApiAvail ) {\n        window.stbSmb.findGroups(function ( error, groups ) {\n            if ( error ) {\n                callback(error);\n            } else if ( Array.isArray(groups) ) {\n                iterateGroups(groups);\n            } else {\n                callback({message: 'Invalid data format!'});\n            }\n        });\n    } else {\n        try {\n            groups = JSON.parse(gSTB.GetSmbGroups());\n        } catch ( error ) {\n            callback(error);\n\n            return;\n        }\n\n        if ( groups && Array.isArray(groups.result) ) {\n            iterateGroups(groups.result);\n        } else {\n            callback({message: 'Invalid data format!'});\n        }\n    }\n}\n\n\n/**\n * Async fetch available servers for given work group.\n *\n * @param {Object} config scan configuration\n * @param {string} config.group SMB group to scan\n * @param {function} callback scan result handler\n * @param {boolean} useCache enable/disable caching for this worker\n */\nfunction getServers ( config, callback, useCache ) {\n    var data, self, servers;\n\n    if ( typeof callback !== 'function' ) {\n        throw new Error('[Network]::getServers()> callback must be a function');\n    }\n\n    useCache = typeof useCache === typeof true ? useCache : true;\n\n    if ( cache.enabled && useCache ) {\n        cache.activeGroup = config.group;\n\n        if ( !cache.data.servers ) {\n            cache.setup(getServers);\n        } else if ( (new Date() - getServers.setupTime) / 1000 > cache.serversCacheTime ) {\n            cache.setup(getServers);\n            // reset data\n            cache.data.servers = null;\n            cache.activeServer = null;\n        } else if ( cache.data.servers[cache.activeGroup] ) {\n            callback(null, cache.data.servers[cache.activeGroup]);\n\n            return;\n        }\n    }\n\n    data = [];\n    self = this; // eslint-disable-line\n\n\n    /**\n     * Iterate through SAMBA servers.\n     *\n     * @param {Object[]} servers retrieved SAMBA servers\n     */\n    function iterateServers ( servers ) {\n        servers.forEach(function ( server ) {\n            if ( server ) {\n                data.push({\n                    name: server,\n                    uri: config.group + '/' + server,\n                    type: self.types.SAMBA_HOST\n                });\n            }\n        });\n\n        cache.data.servers = cache.data.servers || {};\n        cache.data.servers[cache.activeGroup] = data;\n        callback(null, data);\n\n        if ( cache.data.shares ) {\n            Object.keys(cache.data.shares).forEach(function ( key ) {\n                if ( servers.indexOf(key) === -1 ) {\n                    delete cache.data.shares[key];\n                }\n            });\n        }\n    }\n\n\n    if ( asyncApiAvail ) {\n        // transform config accordingly to API version method signature\n        window.stbSmb.findServers(apiVersion === 342 ? config.group : config, function ( error, servers ) {\n            if ( error ) {\n                callback(error);\n            } else if ( Array.isArray(servers) ) {\n                iterateServers(servers);\n            } else {\n                callback({message: 'Invalid data format!'});\n            }\n        });\n    } else {\n        try {\n            servers = JSON.parse(gSTB.GetSmbServers(JSON.stringify(config)));\n        } catch ( error ) {\n            callback(error);\n\n            return;\n        }\n\n        if ( servers && Array.isArray(servers.result) ) {\n            iterateServers(servers.result);\n        } else {\n            callback({message: 'Invalid data format!'});\n        }\n    }\n}\n\n\n/**\n * Async fetch available Samba shares for the given server.\n *\n * @param {Object} config scan configuration\n * @param {string} config.server server name to scan\n * @param {string} [config.login=guest] server account login\n * @param {string} [config.password] server account password\n * @param {function} callback scan result handler\n * @param {boolean} useCache enable/disable caching for this worker\n */\nfunction getShares ( config, callback, useCache ) {\n    var data, shares;\n\n    if ( typeof callback !== 'function' ) {\n        throw new Error('[Network]::getShares()> callback must be a function');\n    }\n\n    useCache = typeof useCache === typeof true ? useCache : true;\n    SMB_MOUNTED = false;\n\n    if ( cache.enabled && useCache ) {\n        cache.activeServer = config.server;\n\n        if ( !cache.data.shares ) {\n            cache.setup(getShares);\n        } else if ( (new Date() - getShares.setupTime) / 1000 > cache.sharesCacheTime ) {\n            cache.setup(getShares);\n            cache.data.shares = null;\n        } else if ( cache.data.shares[cache.activeServer] ) {\n            callback(null, cache.data.shares[cache.activeServer]);\n\n            return;\n        }\n    }\n\n    data = [];\n\n\n    /**\n     * Iterate through SAMBA shares.\n     *\n     * @param {Object[]} shares list of SAMBA shares\n     * @param {*} error occurred error\n     * @param {Object[]} ips list of resolved IP addresses\n     */\n    function iterateShares ( shares, error, ips ) {\n        if ( error ) {\n            callback(error);\n        } else {\n            shares.forEach(function ( share ) {\n                if ( share ) {\n                    data.push({\n                        name: share,\n                        //address: '//' + server + '/' + share,\n                        addresses: ips\n                        //server: server\n                        //type: self.types.SAMBA_SHARE\n                    });\n                }\n            });\n\n            cache.data.shares = cache.data.shares || {};\n            cache.data.shares[cache.activeServer] = data;\n            callback(null, data);\n        }\n    }\n\n\n    if ( asyncApiAvail ) {\n        if ( apiVersion === 342 ) {\n            window.stbSmb.findShares('\"\"', config.server, function ( error, shares ) {\n                if ( error ) {\n                    callback(error);\n                } else if ( Array.isArray(shares) ) {\n                    window.stbSmb.findIp('\"\"', config.server, function ( error, ips ) {\n                        iterateShares(shares, error, ips);\n                    });\n                } else {\n                    callback({message: 'Invalid data format!'});\n                }\n            });\n        } else {\n            window.stbSmb.findShares(config, function ( error, shares ) {\n                if ( error ) {\n                    callback(error);\n                } else if ( Array.isArray(shares) ) {\n                    window.stbSmb.findIps({server: config.server}, function ( error, ips ) {\n                        iterateShares(shares, error, ips);\n                    });\n                } else {\n                    callback({message: 'Invalid data format!'});\n                }\n            });\n        }\n    } else {\n        try {\n            shares = JSON.parse(gSTB.GetSmbShares(JSON.stringify(config)));\n        } catch ( error ) {\n            callback(error);\n\n            return;\n        }\n\n        if ( shares && shares.result && Array.isArray(shares.result.shares) ) {\n            shares.result.shares.forEach(function ( share ) {\n                if ( share ) {\n                    data.push({\n                        name: share,\n                        addresses: [shares.result.serverIP].concat(shares.result.additionalIPs || [])\n                        //type: self.types.SAMBA_SHARE\n                    });\n                }\n            });\n\n            cache.data.shares = cache.data.shares || {};\n            cache.data.shares[cache.activeServer] = data;\n            callback(null, data);\n        } else {\n            callback({message: 'Invalid data format!'});\n        }\n    }\n}\n\n\n/**\n * Open particular SMB share.\n *\n * @param {Object} config opener configuration\n * @param {function} callback scan result handler\n */\nfunction openShare ( config, callback ) {\n    var idx = 0,\n        addresses = config.addresses;\n\n    while ( idx < addresses.length ) {\n        mountSmb({address: '//' + addresses[idx] + '/' + config.folder, login: config.login, password: config.password});\n\n        if ( SMB_MOUNTED ) {\n            break;\n        }\n\n        idx += 1;\n    }\n\n    setTimeout(function () {\n        callback(null, SMB_MOUNTED);\n    }, 0);\n}\n\n\nmodule.exports = {\n    onAppInit: function ( config, callback ) {\n        var api = {\n            config: config.app,\n            types: {\n                SAMBA_GROUP: 0,\n                SAMBA_HOST: 1,\n                SAMBA_SHARE: 2\n            },\n            clearCache: cache.clear,\n            getGroups: getGroups,\n            getServers: getServers,\n            getShares: getShares,\n            openShare: openShare\n        };\n\n        // dome some asynchronous operations\n        callback(null, api);\n    }\n};\n"],"sourceRoot":""}